<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Kafka VS RocketMQ VS RabbitMQ]]></title>
      <url>/2017/08/02/mq/mq/Manual-MQ%E5%AF%B9%E6%AF%94-configure-20170630/</url>
      <content type="html"><![CDATA[<p>本文通过在设计定位，基础对比，可用性、可靠性比较，功能对比，运维成本上对Kafka、RocketMQ、RabbitMQ做了一个对比，希望能够帮助大家对这三个MQ有一些比较具像的理解，并为大家开发选型提供帮助。</p>
<a id="more"></a>
<h3 id="1-Kafka-VS-RocketMQ-VS-RabbitMQ"><a href="#1-Kafka-VS-RocketMQ-VS-RabbitMQ" class="headerlink" title="1 Kafka VS RocketMQ VS RabbitMQ"></a>1 Kafka VS RocketMQ VS RabbitMQ</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th>kafka</th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
<th>数据来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计定位</td>
<td>设计定位</td>
<td>系统间的数据流管道，实时数据处理。<br>例如：常规的消息系统、网站活性跟踪，监控数据，日志收集、处理等”</td>
<td>“非日志的可靠消息传输。<br>例如：订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等”</td>
<td>可靠消息传输。和RocketMQ类似。</td>
<td></td>
</tr>
<tr>
<td>基础对比</td>
<td>成熟度</td>
<td>日志领域成熟</td>
<td>成熟</td>
<td>成熟</td>
<td></td>
</tr>
<tr>
<td></td>
<td>所属社区／公司</td>
<td>Apache</td>
<td>Alibaba开发，已加入到Apache下</td>
<td>Mozilla Public License</td>
<td></td>
</tr>
<tr>
<td></td>
<td>社区活跃度</td>
<td>高</td>
<td>中</td>
<td>高</td>
<td>来源于网络</td>
</tr>
<tr>
<td></td>
<td>API完备性</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td></td>
</tr>
<tr>
<td></td>
<td>文档完备性</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>来源于网络</td>
</tr>
<tr>
<td></td>
<td>开发语言</td>
<td>Scala</td>
<td>Java</td>
<td>Erlang</td>
<td></td>
</tr>
<tr>
<td></td>
<td>支持协议</td>
<td>一套自行设计的基于TCP的二进制协议</td>
<td>自己定义的一套</td>
<td>AMQP</td>
<td></td>
</tr>
<tr>
<td></td>
<td>客户端语言</td>
<td>C/C++、Python、Go、Erlang、.NET、Ruby、Node.js、PHP等</td>
<td>Java</td>
<td>Java、C、 C++、 Python、 PHP、Perl 等</td>
<td></td>
</tr>
<tr>
<td></td>
<td>持久化方式</td>
<td>磁盘文件</td>
<td>磁盘文件</td>
<td>内存、文件</td>
<td></td>
</tr>
<tr>
<td>可用性、可靠性比较</td>
<td>部署方式</td>
<td>单机／集群</td>
<td>单机／集群</td>
<td>单机／集群</td>
<td></td>
</tr>
<tr>
<td></td>
<td>集群管理</td>
<td>zookeeper</td>
<td>name server</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>选主方式</td>
<td>从ISR中自动选举一个leader</td>
<td>不支持自动选主。通过设定brokername、brokerId实现，brokername相同，brokerid=0时为maser，其他为slave</td>
<td>最早加入集群的broker</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可用性</td>
<td>非常高 <br>分布式、主从</td>
<td>非常高 <br>分布式、主从</td>
<td>高 <br>主从，采用镜像模式实现，数据量大时可能产生性能瓶颈”</td>
<td></td>
</tr>
<tr>
<td></td>
<td>主从切换</td>
<td>自动切换 <br>N个副本，允许N-1个失效；master失效以后自动从isr中选择一个主；</td>
<td>不支持自动切换 <br>master失效以后不能向master发送信息，consumer大概30s（默认）可以感知此事件，此后从slave消费；如果master无法恢复，异步复制时可能出现部分信息丢失</td>
<td>自动切换 <br>最早加入集群的slave会成为master；因为新加入的slave不同步master之前的数据，所以可能会出现部分数据丢失</td>
<td></td>
</tr>
<tr>
<td></td>
<td>数据可靠性</td>
<td>很好 <br>支持producer单条发送、同步刷盘、同步复制、异步。</td>
<td>很好 <br>producer单条发送，broker端支持同步刷盘、异步刷盘，同步双写，异步复制。</td>
<td>好 <br>producer支持同步／异步ack。支持队列数据持久化，镜像模式中支持主从同步”</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消息写入性能</td>
<td>非常好 <br>每条10个字节测试：百万条/s</td>
<td>很好 <br>每条10个字节测试：单机单broker约7w/s，单机3个broker约12w/s</td>
<td>RAM约为RocketMQ的1/2，<br> Disk的性能约为RAM性能的1/3</td>
<td>数据来源于网络 <br>单条消息的数据量越小，性能对比时kafka表现越好</td>
</tr>
<tr>
<td></td>
<td>性能的稳定性</td>
<td>队列/分区多时性能不稳定，明显下降。消息堆积时性能稳定</td>
<td>队列较多、消息堆积时性能稳定</td>
<td>消息堆积时，性能不稳定、明显下降</td>
<td></td>
</tr>
<tr>
<td></td>
<td>单机支持的队列数</td>
<td>单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</td>
<td>单机支持最高5万个队列，Load不会发生明显变化</td>
<td>依赖于内存</td>
<td>数据来源于网络测评 <br>kafka新能降低是因为topic增多时，顺序写变成了随机写”</td>
</tr>
<tr>
<td></td>
<td>堆积能力</td>
<td>非常好 <br>消息存储在log中，每个分区由一个或多个segment  log文件</td>
<td>非常好 <br>所有消息存储在同一个commit log中</td>
<td>一般 <br>生产者、消费者正常时，性能表现稳定；消费者不消费时，性能不稳定</td>
<td></td>
</tr>
<tr>
<td></td>
<td>复制备份</td>
<td>消息先写入leader的log，followers从leader中pull数据，pull到数据以后先ack leader，然后写入log中。 <br>ISR中维护与leader同步的列表，落后太多的follwer会被删除掉</td>
<td>同步双写 <br>异步复制：slave启动线程从master中拉数据</td>
<td>普通模式下不复制；<br>镜像模式下：消息先到mster，然后写到slave上。加入集群之前的消息不会被复制到新的slave上。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消息投递实时性</td>
<td>毫秒级<br>具体由consumer轮询间隔时间决定</td>
<td>毫秒级</td>
<td>支持pull、push两种模式，延时通常在毫秒级</td>
<td>毫秒级</td>
</tr>
<tr>
<td>功能对比</td>
<td>顺序消费</td>
<td>支持顺序消费</td>
<td>支持顺序消费 <br>在顺序消息场景下，消费失败时消费队列将会暂停</td>
<td>支持顺序消费</td>
<td></td>
</tr>
<tr>
<td></td>
<td>定时消息</td>
<td>不支持</td>
<td>开源版本仅支持定时Level</td>
<td>不支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>事务消息</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Broker端消息过滤</td>
<td>不支持</td>
<td>支持 <br>通过tag过滤，类似于子topic</td>
<td>不支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消息查询</td>
<td>不支持</td>
<td>支持 <br>根据MessageId查询<br>支持根据MessageKey查询消息</td>
<td>不支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消费失败重试</td>
<td>不支持失败重试 <br>offset存储在consumer中，无法保证。<br>0.8.2版本后支持将offset存储在zk中</td>
<td>支持失败重试 <br>offset存储在broker中</td>
<td>支持失败重试</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消息重新消费</td>
<td>支持通过修改offset来重新消费</td>
<td>支持按照时间来重新消息</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>发送端负载均衡</td>
<td>可自由指定</td>
<td>可自由指定</td>
<td>需要单独loadbalancer支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消费并行度</td>
<td>消费并行度和分区数一致</td>
<td>顺序消费：消费并行度和分区数一致 <br>乱序消费：消费服务器的消费线程数之和</td>
<td>可一次抓取多条一起消费。 <br>镜像模式下其实也是从master消费</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消费方式</td>
<td>consumer pull</td>
<td>consumer pull ／broker push</td>
<td>broker push</td>
<td></td>
</tr>
<tr>
<td></td>
<td>批量发送</td>
<td>支持 <br>默认producer缓存、压缩，然后批量发送</td>
<td>不支持</td>
<td>不支持</td>
<td></td>
</tr>
<tr>
<td></td>
<td>消息清理</td>
<td>指定文件保存时间，过期删除</td>
<td>指定文件保存时间，过期删除</td>
<td>Consumer ack以后，消息将被标记为删除 <br>可用内存少于40%（默认），触发gc，gc时找到相邻的两个文件，合并right文件到left。</td>
<td></td>
</tr>
<tr>
<td>运维</td>
<td>系统维护</td>
<td>Scala语言开发，维护成本高</td>
<td>java语言开发，维护成本低</td>
<td>Erlang语言开发，维护成本高</td>
<td></td>
</tr>
<tr>
<td></td>
<td>部署依赖</td>
<td>zookeeper</td>
<td>nameserver</td>
<td>Erlang环境</td>
<td></td>
</tr>
<tr>
<td></td>
<td>管理后台</td>
<td>官网不提供，第三方开源管理工具可供使用；不用重新开发</td>
<td>官方提供，rocketmq-console</td>
<td>官方提供rabbitmqadmin</td>
<td></td>
</tr>
<tr>
<td></td>
<td>管理后台功能</td>
<td>Kafka Web Conslole  <br> Brokers列表；Kafka 集群中 Topic列表，及对应的Partition、LogSize等信息；Topic对应的Consumer Groups、Offset、Lag等信息；生产和消费流量图、消息预览 <br>KafkaOffsetMonitor： <br>Kafka集群状态；Topic、Consumer Group列表；图形化展示topic和consumer之间的关系；图形化展示consumer的Offset、Lag等信息 <br>Kafka Manager:管理几个不同的集群；监控集群的状态(topics, brokers, 副本分布, 分区分布)；产生分区分配(Generate partition assignments)基于集群的当前状态；重新分配分区</td>
<td>Cluster、Topic、Connection、NameServ、Message、Broker、Offset、Consumer</td>
<td>overview、connections、channels、exchanges、queues、admin</td>
<td></td>
</tr>
<tr>
<td>总结</td>
<td>优点</td>
<td>1、在高吞吐、低延迟、高可用、集群热扩展、集群容错上有非常好的表现； <br>2、producer端提供缓存、压缩功能，可节省性能，提高效率。 <br>3、提供顺序消费能力 <br>4、提供多种客户端语言 <br>5、生态完善，在大数据处理方面有大量配套的设施。</td>
<td>1、在高吞吐、低延迟、高可用上有非常好的表现；消息堆积时，性能也很好。 <br>2、api、系统设计都更加适在业务处理的场景。 <br>3、支持多种消费方式。 <br>4、支持broker消息过滤。 <br>5、支持事务。 <br>6、提供消息顺序消费能力；consumer可以水平扩展，消费能力很强。 <br>7、集群规模在50台左右，单日处理消息上百亿；经历过大数据量的考验，比较稳定可靠。</td>
<td><br>1、在高吞吐量、高可用上较前两者有所不如。 <br>2、支持多种客户端语言；支持amqp协议。 <br>3、由于erlang语言的特性，性能也比较好; 使用RAM模式时，性能很好。 <br>4、管理界面较丰富，在互联网公司也有较大规模的应用;</td>
<td>数据来自网络</td>
</tr>
<tr>
<td></td>
<td>缺点</td>
<td>1、消费集群数目受到分区数目的限制。 <br>2、单机topic多时，性能会明显降低。 <br>3、不支持事务</td>
<td>1、相比于kafka，使用者较少，生态不够完善。消息堆积、吞吐率上也有所不如。 <br>2、不支持主从自动切换，master失效后，消费者需要一定的时间才能感知。 <br>3、客户端只支持Java</td>
<td>1、erlang 语言难度较大。集群不支持动态扩展。 <br>2、不支持事务、消息吞吐能力有限 <br>3、消息堆积时，性能会明显降低</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="2-参考博客"><a href="#2-参考博客" class="headerlink" title="2 参考博客"></a>2 参考博客</h3><p>上述内容，主要参考以下博客内容。</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>rabbitMQ集群部署</td>
<td><a href="http://www.cnblogs.com/knowledgesea/p/6535766.html" target="_blank" rel="external">http://www.cnblogs.com/knowledgesea/p/6535766.html</a></td>
</tr>
<tr>
<td>RabbitMQ可用性、可靠性分析</td>
<td><a href="http://blog.csdn.net/cadem/article/details/53422912?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">http://blog.csdn.net/cadem/article/details/53422912?utm_source=itdadao&amp;utm_medium=referral</a></td>
</tr>
<tr>
<td>kafka也同步刷盘，但是效率较低</td>
<td><a href="http://jm.taobao.org/2016/04/28/kafka-vs-rocktemq-4/" target="_blank" rel="external">http://jm.taobao.org/2016/04/28/kafka-vs-rocktemq-4/</a></td>
</tr>
<tr>
<td>kafka vs RocktMQ</td>
<td><a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines" target="_blank" rel="external">https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines</a></td>
</tr>
<tr>
<td>kafka vs RocktMQ VS RabbitMQ</td>
<td><a href="http://www.cnblogs.com/felixzh/p/6198070.html" target="_blank" rel="external">http://www.cnblogs.com/felixzh/p/6198070.html</a> <br> <a href="http://ju.outofmemory.cn/entry/177937" target="_blank" rel="external">http://ju.outofmemory.cn/entry/177937</a></td>
</tr>
<tr>
<td>Kafka vs RocketMQ Topic数量对单机性能的影响</td>
<td><a href="http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/?utm_source=tuicool&amp;utm_medium=referral</a> <br> <a href="http://www.cnblogs.com/purpleraintear/p/6033136.html" target="_blank" rel="external">http://www.cnblogs.com/purpleraintear/p/6033136.html</a></td>
</tr>
<tr>
<td>kafka管理后台比较</td>
<td><a href="http://top.jobbole.com/31084/" target="_blank" rel="external">http://top.jobbole.com/31084/</a></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> MQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC使用详解]]></title>
      <url>/2017/07/02/spring/framework/Manual-spring-configure-20170630/</url>
      <content type="html"><![CDATA[<p>这里先讲述spring MVC使用详解，主要介绍web.xml、spring MVC常用注解标签、Bean概述。</p>
<a id="more"></a>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。</p>
<p>这里先讲述spring MVC使用详解，主要介绍web.xml、spring MVC常用注解标签、Bean概述。</p>
<h3 id="2-web-xml详解"><a href="#2-web-xml详解" class="headerlink" title="2 web.xml详解"></a>2 web.xml详解</h3><h4 id="2-1-web-xml示例"><a href="#2-1-web-xml示例" class="headerlink" title="2.1 web.xml示例"></a>2.1 web.xml示例</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"3.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 在Spring框架中是如何解决从页面传来的字符串的编码问题的呢？</span></div><div class="line">    下面我们来看看Spring框架给我们提供过滤器CharacterEncodingFilter</div><div class="line">    这个过滤器就是针对于每次浏览器请求进行过滤的，然后再其之上添加了父类没有的功能即处理字符编码。</div><div class="line">    其中encoding用来设置编码格式，forceEncoding用来设置是否理会 request.getCharacterEncoding()方法，</div><div class="line">    设置为true则强制覆盖之前的编码格式。--&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Set Character Encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Set Character Encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- 项目中使用Spring 时，applicationContext.xml配置文件中并没有BeanFactory，要想在业务层中的class 文件中直接引用Spring容器管理的bean可通过以下方式--&gt;</span></div><div class="line">    <span class="comment">&lt;!--1、在web.xml配置监听器ContextLoaderListener--&gt;</span></div><div class="line">    <span class="comment">&lt;!--ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，</span></div><div class="line">    在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，</div><div class="line">    所以整个加载配置过程由ContextLoader来完成。--&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--2、部署applicationContext的xml文件--&gt;</span></div><div class="line">    <span class="comment">&lt;!--如果在web.xml中不写任何参数配置信息，默认的路径是"/WEB-INF/applicationContext.xml，</span></div><div class="line">    在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml。</div><div class="line">    如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数：</div><div class="line">    在&lt;param-value&gt; &lt;/param-value&gt;里指定相应的xml文件名，如果有多个xml文件，可以写在一起并以“,”号分隔。</div><div class="line">    也可以这样applicationContext-*.xml采用通配符，比如这那个目录下有applicationContext-ibatis-base.xml，</div><div class="line">    applicationContext-action.xml，applicationContext-ibatis-dao.xml等文件，都会一同被载入。</div><div class="line">    在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。--&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--如果你的DispatcherServlet拦截"/"，为了实现REST风格，拦截了所有的请求，那么同时对*.js,*.jpg等静态文件的访问也就被拦截了。--&gt;</span></div><div class="line">    <span class="comment">&lt;!--方案一：激活Tomcat的defaultServlet来处理静态文件--&gt;</span></div><div class="line">    <span class="comment">&lt;!--要写在DispatcherServlet的前面， 让 defaultServlet先拦截请求，这样请求就不会进入Spring了。--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.css<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.ico<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.gif<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.bmp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.png<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.txt<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.map<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!--使用Spring MVC,配置DispatcherServlet是第一步。DispatcherServlet是一个Servlet,,所以可以配置多个DispatcherServlet--&gt;</span></div><div class="line">    <span class="comment">&lt;!--DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据规则分发到目标Controller来处理。--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--在DispatcherServlet的初始化过程中，框架会在web应用的 WEB-INF文件夹下寻找名为[servlet-name]-servlet.xml 的配置文件，生成文件中定义的bean。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--指明了配置文件的文件名，不使用默认配置文件名，而使用dispatcher-servlet.xml配置文件。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--其中&lt;param-value&gt;**.xml&lt;/param-value&gt; 这里可以使用多种写法--&gt;</span></div><div class="line">            <span class="comment">&lt;!--1、不写,使用默认值:/WEB-INF/&lt;servlet-name&gt;-servlet.xml--&gt;</span></div><div class="line">            <span class="comment">&lt;!--2、&lt;param-value&gt;/WEB-INF/classes/dispatcher-servlet.xml&lt;/param-value&gt;--&gt;</span></div><div class="line">            <span class="comment">&lt;!--3、&lt;param-value&gt;classpath*:dispatcher-servlet.xml&lt;/param-value&gt;--&gt;</span></div><div class="line">            <span class="comment">&lt;!--4、多个值用逗号分隔--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/dispatcher-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!--load-on-startup是启动顺序，让这个Servlet随Servletp容器一起启动。--&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--这个Servlet的名字是dispatcher，可以有多个DispatcherServlet，是通过名字来区分的。每一个DispatcherServlet有自己的WebApplicationContext上下文对象。同时保存的ServletContext中和Request对象中.--&gt;</span></div><div class="line">        <span class="comment">&lt;!--ApplicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”了:P，Spring把Bean放在这个容器中，在需要的时候，用getBean方法取出--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--Servlet拦截匹配规则可以自已定义，当映射为@RequestMapping("/user/add")时，为例,拦截哪种URL合适？--&gt;</span></div><div class="line">        <span class="comment">&lt;!--1、拦截*.do、*.htm， 例如：/user/add.do,这是最传统的方式，最简单也最实用。不会导致静态文件（jpg,js,css）被拦截。--&gt;</span></div><div class="line">        <span class="comment">&lt;!--2、拦截/，例如：/user/add,可以实现现在很流行的REST风格。很多互联网类型的应用很喜欢这种风格的URL。弊端：会导致静态文件（jpg,js,css）被拦截后不能正常显示。 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--会拦截URL中带“/”的请求。--&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span><span class="comment">&lt;!--指定欢迎页面--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span> <span class="comment">&lt;!--当系统出现404错误，跳转到页面nopage.html--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/nopage.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span> <span class="comment">&lt;!--当系统出现java.lang.NullPointerException，跳转到页面error.html--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.NullPointerException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span><span class="comment">&lt;!--会话超时配置，单位分钟--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>360<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="2-2-加载过程"><a href="#2-2-加载过程" class="headerlink" title="2.2 加载过程"></a>2.2 加载过程</h4><p>1、启动web项目时候，容器首先会去它的配置文件web.xml读取两个节点:  <code>&lt;listener&gt;&lt;/listener&gt;和&lt;context-param&gt;&lt;/context-param&gt;</code>。</p>
<p>2、容器创建一个ServletContext（application），这个WEB项目所有部分都将共享这个上下文。</p>
<p>3、容器以<code>&lt;context-param&gt;&lt;/context-param&gt;</code>的name作为键，value作为值，将其转化为键值对，存入ServletContext。</p>
<p>4、容器创建<code>&lt;listener&gt;&lt;/listener&gt;</code>中的类实例，根据配置的class类路径<code>&lt;listener-class&gt;</code>来创建监听，在监听中会有<code>contextInitialized(ServletContextEvent args)</code><br>初始化方法，启动Web应用时，系统调用Listener的该方法，在该方法中获得：</p>
<p><code>ServletContext application = ServletContextEvent.getServletContext();</code></p>
<p><code>context-param(value) = application.getInitParameter(&quot;context-param(key)&quot;);</code></p>
<p>得到这个context-param的值之后，可以做一些操作了。</p>
<p>5、容器读取<code>&lt;filter&gt;&lt;/filter&gt;</code>，根据指定的类路径来实例化过滤器。</p>
<p>以上都是在WEB项目还没有完全启动起来的时候就已经完成了的工作。如果系统中有Servlet，则Servlet是在第一次发起请求的时候被实例化的，而且一般不会被容器销毁，它可以服务于多个用户的请求。所以，Servlet的初始化都要比上面提到的那几个要迟；</p>
<p>总的来说，web.xml的加载顺序是:<code>&lt;context-param&gt;-&gt; &lt;listener&gt; -&gt; &lt;filter&gt; -&gt; &lt;servlet&gt;</code></p>
<p>其中，如果web.xml中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载；</p>
<p>对于某类元素而言，与它们出现的顺序是有关的。以<code>&lt;filter&gt;</code>为例，web.xml中当然可以定义多个<code>&lt;filter&gt;</code>，与<code>&lt;filter&gt;</code>相关的一个元素是<code>&lt;filter-mapping&gt;</code>，对于拥有相同<code>&lt;filter-name&gt;</code>的<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>元素而言，<code>&lt;filter-mapping&gt;</code>必须出现在<code>&lt;filter&gt;</code>之后，否则当解析到<code>&lt;filter-mapping&gt;</code>时，它所对应的<code>&lt;filter-name&gt;</code>还未定义。web容器启动初始化每个<code>&lt;filter&gt;</code>时，按照<code>&lt;filter&gt;</code>出现的顺序来初始化的，当请求资源匹配多个<code>&lt;filter-mapping&gt;</code>时，<code>&lt;filter&gt;</code>拦截资源是按照<code>&lt;filter-mapping&gt;</code>元素出现的顺序来依次调用<code>doFilter()</code>方法的。<code>&lt;servlet&gt;</code>同<code>&lt;filter&gt;</code>类似。</p>
<h4 id="2-3标签详解"><a href="#2-3标签详解" class="headerlink" title="2.3标签详解"></a>2.3标签详解</h4><h5 id="2-3-1-display-name"><a href="#2-3-1-display-name" class="headerlink" title="2.3.1 display-name"></a>2.3.1 display-name</h5><p>定义了WEB应用的名字</p>
<h5 id="2-3-2-description"><a href="#2-3-2-description" class="headerlink" title="2.3.2 description"></a>2.3.2 description</h5><p>声明WEB应用的描述信息</p>
<h5 id="2-3-3-context-param"><a href="#2-3-3-context-param" class="headerlink" title="2.3.3 context-param"></a>2.3.3 context-param</h5><p>声明应用范围内的初始化参数。</p>
<h6 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>&lt;context-param&gt;</code>元素含有一对参数名和参数值，用作应用的Servlet上下文初始化参数，参数名在整个Web应用中必须是惟一的，在web应用的整个生命周期中上下文初始化参数都存在，任意的Servlet和jsp都可以随时随地访问它。<code>&lt;param-name&gt;</code>子元素包含有参数名，而<code>&lt;param-value&gt;</code>子元素包含的是参数值。作为选择，可用<code>&lt;description&gt;</code>子元素来描述参数。</p>
<h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><p>比如：定义一个管理员email地址用来从程序发送错误，或者与你整个应用程序有关的其他设置。使用自己定义的设置文件需要额外的代码和管理；直接在你的程序中使用硬编码（Hard-coding）参数值会给你之后修改程序带来麻烦，更困难的是，要根据不同的部署使用不同的设置；通过这种办法，可以让其他开发人员更容易找到相关的参数，因为它是一个用于设置这种参数的标准位置。</p>
<h5 id="2-3-4-filter"><a href="#2-3-4-filter" class="headerlink" title="2.3.4 filter"></a>2.3.4 filter</h5><p>过滤器元素将一个名字与一个实现<code>javax.servlet.Filter</code>接口的类相关联。</p>
<h6 id="配置：-1"><a href="#配置：-1" class="headerlink" title="配置："></a>配置：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>         </div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>xxx.xxx<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div></pre></td></tr></table></figure>
<h6 id="Filter介绍："><a href="#Filter介绍：" class="headerlink" title="Filter介绍："></a>Filter介绍：</h6><p>Filter可认为是Servle的一种“加强版”，主要用于对用户请求request进行预处理，也可以对Response进行后处理，是个典型的处理链。使用Filter的完整流程是：Filter对用户请求进行预处理，接着将请求HttpServletRequest交给Servlet进行处理并生成响应，最后Filter再对服务器响应HttpServletResponse进行后处理。Filter与Servlet具有完全相同的生命周期，且Filter也可以通过<code>&lt;init-param&gt;</code>来配置初始化参数，获取Filter的初始化参数则使用FilterConfig的<code>getInitParameter()</code>。换种说法，Servlet里有request和response两个对象，Filter能够在一个request到达Servlet之前预处理request，也可以在离开Servlet时处理response，Filter其实是一个Servlet链。Filter的一些常见应用场合包括：认证、日志和审核、图片转换、数据压缩、密码、令牌、触发资源访问事件、XSLT、媒体类型链等。Filter可负责拦截多个请求或响应，一个请求或响应也可被多个Filter拦截。</p>
<p>Filter必须实现<code>javax.servlet.Filter</code>接口，在该接口中定义了三个方法：</p>
<p>(1)、<code>void init(FilterConfig config)</code>：用于完成Filter的初始化。FilteConfig用于访问Filter的配置信息。</p>
<p>(2)、<code>void destroy()</code>：用于Filter销毁前，完成某些资源的回收。</p>
<p>(3)、<code>void doFilter(ServletRequest request,ServletResponse response,FilterChain chain)</code>：实现过滤功能的核心方法，该方法就是对每个请求及响应增加额外的处理。该方法实现对用户请求request进行预处理，也可以实现对服务器响应response进行后处理，它们的分界线为是否调用了<code>chain.doFilter(request，response)</code>，执行该方法之前，即对用户请求request进行预处理，执行该方法之后，即对服务器响应response进行后处理。</p>
<h6 id="Filter配置："><a href="#Filter配置：" class="headerlink" title="Filter配置："></a>Filter配置：</h6><p>Filter配置与Servlet的配置非常相似，需要配置两部分：配置Filter名称和Filter拦截器URL模式。区别在于Servlet通常只配置一个URL，而Filter可以同时配置多个请求的URL。配置Filter有两种方式：</p>
<p>(1)、在Filter类中通过Annotation进行配置。</p>
<p>(2)、在web.xml文件中通过配置文件进行配置。</p>
<p>我们使用的是web.xml这种配置方式，下面重点介绍<code>&lt;filter&gt;</code>内包含的一些元素。</p>
<p><code>&lt;filter&gt;</code>用于指定Web容器中的过滤器，可包含<code>&lt;filter-name&gt;、&lt;filter-class&gt;、&lt;init-param&gt;、&lt;icon&gt;、&lt;display-name&gt;、&lt;description&gt;</code>。</p>
<p><code>&lt;filter-name&gt;</code>用来定义过滤器的名称，该名称在整个程序中都必须唯一。</p>
<p><code>&lt;filter-class&gt;</code>元素指定过滤器类的完全限定的名称，即Filter的实现类。</p>
<p><code>&lt;init-param&gt;</code>为Filter配置参数，与<code>&lt;context-param&gt;</code>具有相同的元素描述符<code>&lt;param-name&gt;</code>和<code>&lt;param-value&gt;</code>。</p>
<p><code>&lt;filter-mapping&gt;</code>元素用来声明Web应用中的过滤器映射，过滤器被映射到一个servlet或一个URL 模式。这个过滤器的<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>必须具有相同的<code>&lt;filter-name&gt;</code>，指定该Filter所拦截的URL。过滤是按照部署描述符的<code>&lt;filter-mapping&gt;</code>出现的顺序执行的。</p>
<h5 id="2-3-5-filter-mapping"><a href="#2-3-5-filter-mapping" class="headerlink" title="2.3.5 filter-mapping"></a>2.3.5 filter-mapping</h5><p>一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet相关联。</p>
<h6 id="配置：-2"><a href="#配置：-2" class="headerlink" title="配置："></a>配置：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Set Character Encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="2-3-6-listener"><a href="#2-3-6-listener" class="headerlink" title="2.3.6 listener"></a>2.3.6 listener</h5><p>servlet API的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。Listener元素指出事件监听程序类。</p>
<h6 id="配置：-3"><a href="#配置：-3" class="headerlink" title="配置："></a>配置：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>xxx.xxx<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure>
<h6 id="listener介绍："><a href="#listener介绍：" class="headerlink" title="listener介绍："></a>listener介绍：</h6><p>web应用程序定义监听器，监听器用来监听各种事件，比如：application和session事件，所有的监听器按照相同的方式定义，功能取决去它们各自实现的接口，常用的Web事件接口有如下几个：</p>
<p>(1)ServletContextListener：用于监听Web应用的启动和关闭；</p>
<p>(2)ServletContextAttributeListener：用于监听ServletContext范围（application）内属性的改变；</p>
<p>(3)ServletRequestListener：用于监听用户的请求；</p>
<p>(4)ServletRequestAttributeListener：用于监听ServletRequest范围（request）内属性的改变；</p>
<p>(5)HttpSessionListener：用于监听用户session的开始和结束；</p>
<p>(6)HttpSessionAttributeListener：用于监听HttpSession范围（session）内属性的改变。</p>
<p><listener>主要用于监听Web应用事件，其中有两个比较重要的WEB应用事件：应用的启动和停止（starting up or shutting down）和Session的创建和失效（created or destroyed）。应用启动事件发生在应用第一次被Servlet容器装载和启动的时候；停止事件发生在Web应用停止的时候。Session创建事件发生在每次一个新的session创建的时候，类似地Session失效事件发生在每次一个Session失效的时候。为了使用这些Web应用事件做些有用的事情，我们必须创建和使用一些特殊的“监听类”。它们是实现了以下两个接口中任何一个接口的简单java类：<code>javax.servlet.ServletContextListener</code>或<code>javax.servlet.http.HttpSessionListener</code>，如果想让你的类监听应用的启动和停止事件，你就得实现ServletContextListener接口；想让你的类去监听Session的创建和失效事件，那你就得实现HttpSessionListener接口；</listener></p>
<h6 id="listener配置："><a href="#listener配置：" class="headerlink" title="listener配置："></a>listener配置：</h6><p>配置Listener只要向Web应用注册Listener实现类即可，无序配置参数之类的东西，因为Listener获取的是Web应用ServletContext（application）的配置参数。为Web应用配置Listener的两种方式：</p>
<p>（1）使用@WebListener修饰Listener实现类即可。</p>
<p>（2）在web.xml文档中使用<code>&lt;listener&gt;</code>进行配置。</p>
<p>我们选择web.xml这种配置方式，只有一个元素<code>&lt;listener-class&gt;</code>指定Listener的实现类，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里的<code>&lt;listener&gt;</code>用于Spring的加载，Spring加载可以利用ServletContextListener实现，也可以采用load-on-startup Servlet实现，但是当<code>&lt;filter&gt;</code>需要用到bean时，但加载顺序是：先加载<code>&lt;filter&gt;</code>后加载<code>&lt;servlet&gt;</code>，则<code>&lt;filter&gt;</code>中初始化操作中的bean为null；所以，如果过滤器中要使用到bean，此时就可以根据加载顺序<code>&lt;listener&gt; -&gt; &lt;filter&gt; -&gt; &lt;servlet&gt;</code>，将spring的加载改成Listener的方式。</p>
<h5 id="2-3-7-servlet"><a href="#2-3-7-servlet" class="headerlink" title="2.3.7 servlet"></a>2.3.7 servlet</h5><p>在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet。</p>
<h6 id="配置：-4"><a href="#配置：-4" class="headerlink" title="配置："></a>配置：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ModelViewController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet</div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:/spring/servlet-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ModelViewController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<h6 id="Servlet介绍："><a href="#Servlet介绍：" class="headerlink" title="Servlet介绍："></a>Servlet介绍：</h6><p>Servlet通常称为服务器端小程序，是运行在服务器端的程序，用于处理及响应客户的请求。Servlet是个特殊的java类，继承于HttpServlet。客户端通常只有GET和POST两种请求方式，Servlet为了响应则两种请求，必须重写<code>doGet()</code>和<code>doPost()</code>方法。大部分时候，Servlet对于所有的请求响应都是完全一样的，此时只需要重写<code>service()</code>方法即可响应客户端的所有请求。另外HttpServlet有两个方法：</p>
<p>（1）<code>init(ServletConfig config)</code>：创建Servlet实例时，调用该方法的初始化Servlet资源。</p>
<p>（2）<code>destroy()</code>：销毁Servlet实例时，自动调用该方法的回收资源。</p>
<p>通常无需重写<code>init()</code>和<code>destroy()</code>两个方法，除非需要在初始化Servlet时，完成某些资源初始化的方法，才考虑重写<code>init()</code>方法，如果重写了<code>init()</code>方法，应在重写该方法的第一行调用<code>super.init(config)</code>，该方法将调用HttpServlet的<code>init()</code>方法。如果需要在销毁Servlet之前，先完成某些资源的回收，比如关闭数据库连接，才需要重写<code>destory()</code>方法。</p>
<p>Servlet的生命周期：创建Servlet实例有两个时机：客户端第一次请求某个Servlet时，系统创建该Servlet的实例，大部分Servlet都是这种Servlet。Web应用启动时立即创建Servlet实例，即load-on-start Servlet。每个Servlet的运行都遵循如下生命周期：</p>
<p>（1）创建Servlet实例。</p>
<p>（2）Web容器调用Servlet的init()方法，对Servlet进行初始化。</p>
<p>（3）Servlet初始化后，将一直存在于容器中，用于响应客户端请求，如果客户端发送GET请求，容器调用Servlet的doGet()方法处理并响应请求；如果客户端发送POST请求，容器调用Servlet的<code>doPost()</code>方法处理并响应请求。或者统一使用<code>service()</code>方法处理来响应用户请求。</p>
<p>（4）Web容器决定销毁Servlet时，先调用Servlet的<code>destory()</code>方法，通常在关闭Web应用时销毁Servlet实例。</p>
<h6 id="Servlet配置："><a href="#Servlet配置：" class="headerlink" title="Servlet配置："></a>Servlet配置：</h6><p>为了让Servlet能响应用户请求，还必须将Servlet配置在web应用中，配置Servlet需要修改web.xml文件。从Servlet3.0开始，配置Servlet有两种方式：</p>
<p>（1）在Servlet类中使用@WebServlet Annotation进行配置。</p>
<p>（2）在web.xml文件中进行配置。</p>
<p>我们用web.xml文件来配置Servlet，需要配置<code>&lt;servlet&gt;</code>和<code>&lt;servlet-mapping&gt;</code>。<code>&lt;servlet&gt;</code>用来声明一个Servlet。<code>&lt;icon&gt;、&lt;display-name&gt;</code>和<code>&lt;description&gt;</code>元素的用法和<code>&lt;filter&gt;</code>的用法相同。<code>&lt;init-param&gt;</code>元素与<code>&lt;context-param&gt;</code>元素具有相同的元素描述符，可以使用<code>&lt;init-param&gt;</code>子元素将初始化参数名和参数值传递给Servlet，访问Servlet配置参数通过ServletConfig对象来完成，ServletConfig提供如下方法：<code>java.lang.String.getInitParameter(java.lang.String name)</code>：用于获取初始化参数。ServletConfig获取配置参数的方法和ServletContext获取配置参数的方法完全一样，只是ServletConfig是取得当前Servlet的配置参数，而ServletContext是获取整个Web应用的配置参数。</p>
<h4 id="3-Spring-MVC注解标签详解"><a href="#3-Spring-MVC注解标签详解" class="headerlink" title="3 Spring MVC注解标签详解"></a>3 Spring MVC注解标签详解</h4><h5 id="3-1-Controller"><a href="#3-1-Controller" class="headerlink" title="3.1 @Controller"></a>3.1 @Controller</h5><p>在SpringMVC中，控制器Controller负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model，然后再把该Model返回给对应的View进行展示。在SpringMVC中提供了一个非常简便的定义Controller的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller标记一个类是Controller，然后使用@RequestMapping 和@RequestParam等一些注解用以定义URL 请求和Controller方法之间的映射，这样的Controller就能被外界访问到。此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet对象，它们可以通过Controller的方法参数灵活的获取到。</p>
<p>@Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是真正处理请求的处理器。单单使用@Controller标记在一个类上还不能真正意义上的说它就是SpringMVC的一个控制器类，因为这个时候Spring还不认识它。那么要如何做Spring才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<p>（1）在SpringMVC的配置文件中定义MyController的bean对象。</p>
<p>（2）在SpringMVC的配置文件中告诉Spring该到哪里去找标记为@Controller的Controller控制器。</p>
<h5 id="3-2-RequestMapping"><a href="#3-2-RequestMapping" class="headerlink" title="3.2 @RequestMapping"></a>3.2 @RequestMapping</h5><p>一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径，属性如下：</p>
<p>A）、value， method</p>
<p>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>
<p>Method：指定请求的method类型， GET、POST、PUT、DELETE等；</p>
<p>B)、consumes，produces</p>
<p>consume:指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p>
<p>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
<p>C)、params，headers</p>
<p>params:指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h5 id="3-3-Resource和-Autowired"><a href="#3-3-Resource和-Autowired" class="headerlink" title="3.3 @Resource和@Autowired"></a>3.3 @Resource和@Autowired</h5><p>@Autowired和@Resource都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入</p>
<h6 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h6><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><p>（1）@Autowired为Spring提供的注解，只按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用；</p>
<p>（2）@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h6 id="Resource装配顺序："><a href="#Resource装配顺序：" class="headerlink" title="@Resource装配顺序："></a>@Resource装配顺序：</h6><p>（1）如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p>
<p>（2）如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p>
<p>（3）如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p>
<p>（4）如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p>
<h5 id="3-4-PathVariable"><a href="#3-4-PathVariable" class="headerlink" title="3.4 @PathVariable"></a>3.4 @PathVariable</h5><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。</p>
<h5 id="3-5-requestParam"><a href="#3-5-requestParam" class="headerlink" title="3.5 @requestParam"></a>3.5 @requestParam</h5><p>@requestParam用于在SpringMVC后台控制层获取参数，类似一种是<code>request.getParameter(&quot;name&quot;)</code>，它有三个常用参数：<code>defaultValue = &quot;0&quot;, required = false, value = &quot;isApp&quot;</code>；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。</p>
<h5 id="3-6-ResponseBody"><a href="#3-6-ResponseBody" class="headerlink" title="3.6 @ResponseBody"></a>3.6 @ResponseBody</h5><p>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区，使用时机返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用。</p>
<h5 id="3-7-RequestBody"><a href="#3-7-RequestBody" class="headerlink" title="3.7 @RequestBody"></a>3.7 @RequestBody</h5><p>注解常用来处理Content-Type:application/json, application/xml等请求参数是请求体。</p>
<h5 id="3-8-ModelAttribute和-SessionAttributes"><a href="#3-8-ModelAttribute和-SessionAttributes" class="headerlink" title="3.8 @ModelAttribute和 @SessionAttributes"></a>3.8 @ModelAttribute和 @SessionAttributes</h5><p>该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法，@SessionAttributes即将值放到session作用域中，写在class上面。</p>
<h5 id="3-9-Component"><a href="#3-9-Component" class="headerlink" title="3.9 @Component"></a>3.9 @Component</h5><p>相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议使用。</p>
<h5 id="3-10-Repository"><a href="#3-10-Repository" class="headerlink" title="3.10 @Repository"></a>3.10 @Repository</h5><p>用于注解dao层，在daoImpl类上面注解。</p>
<h5 id="3-11-RestController："><a href="#3-11-RestController：" class="headerlink" title="3.11 @RestController："></a>3.11 @RestController：</h5><p>经常见到一些控制器实现了REST的API，只为服务于JSON，XML或其它自定义的类型内容，@RestController用来创建REST类型的控制器，与@Controller类型。@RestController就是这样一种类型，它避免了你重复的写@RequestMapping与@ResponseBody。</p>
<h3 id="4-Bean概述"><a href="#4-Bean概述" class="headerlink" title="4 Bean概述"></a>4 Bean概述</h3><h4 id="4-1-命名空间"><a href="#4-1-命名空间" class="headerlink" title="4.1 命名空间"></a>4.1 命名空间</h4><h6 id="ns"><a href="#ns" class="headerlink" title="ns:"></a>ns:</h6><p>namespace，表示命名空间。</p>
<h6 id="xsd文件："><a href="#xsd文件：" class="headerlink" title="xsd文件："></a>xsd文件：</h6><p>定义了它所控制的spring配置文件能够写的具体内容。所以说这个xsd文件就是这个spring配置文件的命名空间。Xmlns表示当前配置文件的namespace其中之一，以“xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;”这个为例，它具体发xsd文件可以通过点击“http://www.springframework.org/schema/context/spring-context-3.0.xsd”进入，是在spring的spring-aop的jar包下，在这里定义了文档中出现的元素、文档中出现的属性、子元素、子元素的数量、子元素的顺序、元素是否为空、元素和属性的数据类型、元素或属性的默认和固定值。" target="_blank" rel="external">http://www.springframework.org/schema/context&quot;”这个为例，它具体发xsd文件可以通过点击“http://www.springframework.org/schema/context/spring-context-3.0.xsd”进入，是在spring的spring-aop的jar包下，在这里定义了文档中出现的元素、文档中出现的属性、子元素、子元素的数量、子元素的顺序、元素是否为空、元素和属性的数据类型、元素或属性的默认和固定值。</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></div><div class="line">   <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">   <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span> <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></div><div class="line">   <span class="attr">xmlns:gconfig</span>=<span class="string">"http://code.greenline.com/schema/gconfig"</span></div><div class="line">   <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd</div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</div><div class="line">        http://www.springframework.org/schema/util</div><div class="line">        http://www.springframework.org/schema/util/spring-util-3.0.xsd</div><div class="line">        http://www.springframework.org/schema/task</div><div class="line">        http://www.springframework.org/schema/task/spring-task-3.0.xsd</div><div class="line">        http://code.greenline.com/schema/gconfig</div><div class="line">        http://code.greenline.com/schema/gconfig/gconfig.xsd</div><div class="line">        http://www.springframework.org/schema/aop</div><div class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</div></pre></td></tr></table></figure></p>
<h6 id="Xsd文件跟xml文件的关系："><a href="#Xsd文件跟xml文件的关系：" class="headerlink" title="Xsd文件跟xml文件的关系："></a>Xsd文件跟xml文件的关系：</h6><p>xsd是xml的语法，所以把xsd称之为元数据，一个xml的语法可以由好几个xsd来确定，早期的xml语法是dtd文件，新的语法是xsd文件，一是据将来的条件可扩展，二是比DTD丰富和有用，三是用XML书写，四是支持数据类型，五是支持命名空间。</p>
<h6 id="Schema："><a href="#Schema：" class="headerlink" title="Schema："></a>Schema：</h6><p>一个xsd文件称之为schema，所以beans.xml中有schemalocation，那为什么是以http开头的呢，需要schema文件互相之间不冲突，总之要起一个独一无二的地址或者名字，所以<code>http://www.springframework.org/schema/context</code>这个表示一个key，一个标识，一个标识意味着独一无二，所以用http网站作为标识是最容易避免冲突的方法，所以标识一般都是以http开头。</p>
<p>关于xsd相关的内容可以参考下面的博文：</p>
<p>（<a href="https://www.ibm.com/developerworks/cn/xml/x-1008dubb/）" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/xml/x-1008dubb/）</a></p>
<h4 id="4-2-别名（alias）"><a href="#4-2-别名（alias）" class="headerlink" title="4.2 别名（alias）"></a>4.2 别名（alias）</h4><h6 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h6><p>在大型软件系统中，可能会有很多子系统的配置，而所有的子系统都有它自己配套的bean，而在你的系统扩展时不希望触及这些原始bean定义（或者不能操作这些bean的名字）时，别名尤其有用。</p>
<h6 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"fromName"</span> <span class="attr">alias</span>=<span class="string">"toName"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>其中，fromName表示同一个容器中原始的bean定义，toName表示这个bean的别名。</p>
<p>举例，子系统A中的配置元数据通过subsystemA-datasource引用一个数据源，子系统B中的配置元数据通过subsystemB-datasource引用这个数据源，使用这两个子系统的主应用通过myApp-datasource引用这个数据源。为了使用这三个名字引用相同的对象，可以在MyApp配置中添加如下的别名定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"subsystemA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"subsystemB-dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"subsystemA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"myApp-dataSource"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>现在每个子系统都可以通过不同的名字引用这个数据源，并且保证了所有这些子系统引用的都是同一个bean，不会与其它任何子系统的定义冲突，它们还引用了同一个bean。</p>
<h4 id="4-3-实例化bean"><a href="#4-3-实例化bean" class="headerlink" title="4.3 实例化bean"></a>4.3 实例化bean</h4><h6 id="使用构造方法实例化"><a href="#使用构造方法实例化" class="headerlink" title="使用构造方法实例化"></a>使用构造方法实例化</h6><p>用构造方法创建bean的方式，被开发的类不需要实现任何特定的接口或以特定的形式编码，仅仅指定bean类就足够了。你可以通过无参的构造方法或者有参的构造方法。有参的构造方法有三种方式。</p>
<p>无参的构造方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>有参数的构造方法：（第一种：根据参数下标）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"*****"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>有参数的构造方法：（第一种：根据参数名称）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"*****"</span> <span class="attr">value</span>=<span class="string">"*****"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>有参数的构造方法：（第一种：根据参数类型）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"*****"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h6 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h6><p>通过静态工厂方法创建bean需要class属性指定那个包含静态工厂方法的类，并使用factory-method属性指定工厂方法的名字。之后它就像用构造方法创建的对象一样对待。如下，其中<code>createInstance()</code>方法必须是静态的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span> <span class="attr">class</span>=<span class="string">"examples.ClientService"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="使用实例的工厂方法实例化（非静态）"><a href="#使用实例的工厂方法实例化（非静态）" class="headerlink" title="使用实例的工厂方法实例化（非静态）"></a>使用实例的工厂方法实例化（非静态）</h6><p>与静态工厂方法不同的是，使用实例的工厂方法实例化是调用非静态方法来创建。其中，</p>
<p>1、没有class属性。</p>
<p>2、factory-bean为包含工厂方法的那个bean的名字。</p>
<p>3、factory-method表示工厂方法的名字。</p>
<p>如下例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span> <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span> <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultServiceLocator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-依赖"><a href="#4-4-依赖" class="headerlink" title="4.4 依赖"></a>4.4 依赖</h4><h5 id="4-4-1-依赖注入"><a href="#4-4-1-依赖注入" class="headerlink" title="4.4.1 依赖注入"></a>4.4.1 依赖注入</h5><p>某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者主动来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转，创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。Spring容器干两件事情：</p>
<p>1、创建对象，（依赖）。创建某一对象的时候，此时依赖的对象已经创建完毕。</p>
<p>2、将对象装配，也可理解为注入。将创建的对象拿过来，通过构造方法或者setter方法注入，称之为装配。</p>
<p>依赖注入有两种主要的方式，基于构造方法的依赖注入和基于setter方法的依赖注入。</p>
<h6 id="基于构造方法的依赖注入"><a href="#基于构造方法的依赖注入" class="headerlink" title="基于构造方法的依赖注入"></a>基于构造方法的依赖注入</h6><p>基于构造方法的依赖注入，由容器调用带有参数的构造方法来完成，每个参数代表一个依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = anotherBean;</div><div class="line">        <span class="keyword">this</span>.beanTwo = yetAnotherBean;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造方法参数的解决：</p>
<p>构造方法参数在匹配时使用参数的类型，所以有可能会存在歧义。首先看没有歧义的配置，如下：其中Bar和Baz类没有继承关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> x.y;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>1、使用简单类型：比如<code>&lt;value&gt;true&lt;/value&gt;</code>，Spring无法判断值的类型，没有类型就没办法匹配。如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</div><div class="line">    <span class="keyword">private</span> String ultimateAnswer;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果使用type属性指定了参数的类型，则容器会使用类型匹配。但是如果不指定类型，spring分不清把7500000赋给year还是42赋给year，因为constructor-arg并不是按它们出现的顺序与参数匹配。</p>
<p>或者使用index属性显式地指定参数的顺序。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>2、多个相同类型的参数：</p>
<p>A、同样可以通过索引解决。（索引从0开始）；</p>
<p>B、或者使用参数的名字来消除起义。如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateAnswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h6 id="基于setter方法的依赖注入"><a href="#基于setter方法的依赖注入" class="headerlink" title="基于setter方法的依赖注入"></a>基于setter方法的依赖注入</h6><p>基于setter方法的依赖注入，由容器在调用无参构造方法或无参静态工厂方法之后调用setter方法来实例化bean。  如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = beanOne;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h6 id="构造方法和setter方法的选择"><a href="#构造方法和setter方法的选择" class="headerlink" title="构造方法和setter方法的选择"></a>构造方法和setter方法的选择</h6><p>setter方法：</p>
<p>(1)、因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。</p>
<p>(2)、对于复杂的依赖关系，如果采用构造注入，会导致构造器国语臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化器依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。尤其是在某些属性可选的情况下，多参数的构造器更加笨重。</p>
<p>构造注入：</p>
<p>(1)、它会使应用程序的组件实现为不可变的对象，并保证必需的依赖不为null；setter方法仅仅只用于可选依赖，这些可选依赖应该在类中被赋值合理的默认值。否则，在使用这项依赖的任何地方都要做非null检查</p>
<p>(2)、构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。例如，组件中其他依赖关系的注入，常常要依赖于DataSrouce的注入。采用构造注入，可以在代码中清晰的决定注入顺序。</p>
<p>(3)、依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</p>
<p>(4)、对于依赖关系不需要变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不需要担心后续的代码对依赖关系产生破坏。</p>
<p>(5)、如果一个第三方类没有暴露任何setter方法，那么只能选择构造方法注入了。</p>
<h5 id="4-4-2-依赖与配置详解"><a href="#4-4-2-依赖与配置详解" class="headerlink" title="4.4.2 依赖与配置详解"></a>4.4.2 依赖与配置详解</h5><h6 id="直接设置值"><a href="#直接设置值" class="headerlink" title="直接设置值"></a>直接设置值</h6><p><code>&lt;property/&gt;</code>的value属性可以为属性或构造方法参数指定字符串形式的值。Spring容器会把这些字符串值转换成参数的实际类型。如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"masterkaoli"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h6 id="ref元素"><a href="#ref元素" class="headerlink" title="ref元素"></a>ref元素</h6><p>ref能够让一个bean的指定属性引用另一个bean。被引用的bean就称为一个依赖，并且在设置前这个依赖的bean就已经被初始化（如果这个bean是单例的，它可能已经被初始化了）。作用域和检验通过bean、local、parent属性指定的另一个对象的id或name决定。bean是最常用的形式，并且可以引用同一个或父容器中的任何bean。</p>
<p>通过parent属性可以指定对当前容器的父容器中的bean的引用。parent属性的值可能是目标bean的id属性或name属性中的一个，而且目标bean必须在当前容器的父容器中。这种引用形式主要出现在有容器继承并且想把父容器中存在的bean包装成同样名字的代理用于子容器的时候。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;&lt;/bean&gt;</div><div class="line">&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;</div><div class="line">    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;</div><div class="line">    &lt;property name="target"&gt;</div><div class="line">        &lt;ref parent="accountService"/&gt; </div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h6 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h6><p>在<code>&lt;list/&gt;, &lt;set/&gt;, &lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素中，可以分别设置Java集合类型List, Set, Map和Properties的属性和参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moreComplexObject"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">Properties：</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"development"</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">List：</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someList"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">Map：</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someMap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"an entry"</span> <span class="attr">value</span>=<span class="string">"just some string"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">"a ref"</span> <span class="attr">value-ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    Set：</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someSet"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>map的键值或set的值也可以是以下任何元素：</p>
<p>bean、ref、idref、 list、set、map、props、value、null</p>
<h6 id="idref元素"><a href="#idref元素" class="headerlink" title="idref元素"></a>idref元素</h6><p>idref元素可以获取spring容器中的bean的name的值（一个字符串），而不是bean的实例。idref元素的功能与<code>&lt;value&gt;</code>类似，只是idref增加了验证的功能，减少配置的书写错误机率。除了<code>&lt;idref bean=&quot;&quot;/&gt;</code>，如果被引用的bean在同一个xml文件中，且bean的名字就是bean的id，除了可以使用<code>&lt;idfef local=&quot;&quot;/&gt;</code>，此属性允许xml解析器在解析XML的时候对引用的bean进行验证。而value方式，传给client bean的targetName属性值并没有被验证。任何的输入错误仅在client bean实际实例化时才会被发现（可能伴随着致命的错误）。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theClientBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>下面是value的方式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span> <span class="attr">value</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>idref元素的local属性在4.0版本的xsd中不再支持了，因为它不提供对普通bean的引用。在升级的4.0的schema时只要把已存在的idref local改成idref bean即可。</p>
<h6 id="集合的合并"><a href="#集合的合并" class="headerlink" title="集合的合并"></a>集合的合并</h6><p>Spring容器支持集合的合并。包括<code>&lt;list/&gt;、&lt;set/&gt;、 &lt;map/&gt;</code>或<code>&lt;props/&gt;</code>元素，子类型可以继承父类型集合的值，也可以重写父集合里的值。其实就是交集的结果，重叠的元素会重写。如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span>       </div><div class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sales"</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>需要在子bean的adminEmails属性上的props元素的merge=true。当child被实例化时，它拥有一个adminEmails Properties集合，这个集合包含了父子两个集合adminEmails合并的结果。</p>
<p><code>administrator=administrator@example.com</code></p>
<p><code>sales=sales@example.com</code></p>
<p><code>support=support@example.co.uk</code></p>
<p>其中<code>&lt;list/&gt;, &lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合的合并也是类似的。在<code>&lt;list/&gt;</code>元素合并的时候，因为List集合维护的是有序的值，所以父集合的值在子集合值的前面。在Map, Set和Properties中的值则不存在顺序。没有顺序的集合类型更有效，因此容器内部更倾向于使用Map, Set和Properties。</p>
<p>集合合并的局限性：不能合并不同的集合类型（比如，Map和List），如果试图这么做将会抛出异常。merge属性必须指定在子集合的定义上，在父集合上指定merge属性将是多余的且不会合并集合。</p>
<h6 id="强类型集合"><a href="#强类型集合" class="headerlink" title="强类型集合"></a>强类型集合</h6><p>Java5引入了泛型类型，所以可以使用强类型的集合。也就是说，例如，可以声明一个只能包含String元素的集合类型。如果使用Spring把强类型的集合注入到一个bean，可以利用Spring的类型转换以便元素在被添加到集合之前转换成合适的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Foo &#123;</div><div class="line">    private Map&lt;String, Float&gt; accounts;</div><div class="line">    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;</div><div class="line">        this.accounts = accounts;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accounts"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"9.99"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"2.75"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"six"</span> <span class="attr">value</span>=<span class="string">"3.99"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当foo的accounts属性准备注入的时候，会通过反射获得强类型<code>Map&lt;String, Float&gt;</code>的泛型信息。然后Spring的类型转换机制识别到value的类型为Float，并把String类型的值9.99，2.75和3.99转换成实际的Float类型。 </p>
<h6 id="null和空字符串值"><a href="#null和空字符串值" class="headerlink" title="null和空字符串值"></a>null和空字符串值</h6><p>Spring把对属性的空参数作为空字符串。下面的XML片段把email属性的值设置成了空字符串值（“”）。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>等价于如下的Java代码：<br><code>exampleBean.setEmail(&quot;&quot;)</code></p>
<p>也可以通过<null>元素来处理值。如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></null></p>
<p>等价于如下的Java代码：<br><code>exampleBean.setEmail(null)</code></p>
<h6 id="使用p命名空间简写XML"><a href="#使用p命名空间简写XML" class="headerlink" title="使用p命名空间简写XML"></a>使用p命名空间简写XML</h6><p>使用<code>&lt;property&gt;</code>元素为Bean的属性装配值和引用并不太复杂。尽管如此，Spring的命名空间p 提供了另一种Bean 属性的装配方式，该方式不需要配置如此多的尖括号。p命名空间使你可以使用bean元素的属性，而不是内置的<code>&lt;property/&gt;</code>元素，来描述属性值和合作的bean。 </p>
<p>Spring支持使用命名空间扩展配置，这是基于XML的schema定义的。本章讨论的bean的配置形式是定义在XML schema文档中的。然而，p命名空间不是定义在XSD文件中的，它存在于Spring的核心包中。标准的XML形式和p命名空间的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"classic"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span></span></div><div class="line">        <span class="attr">p:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>p命名空间没有schema定义，所以可以把xml的属性名设置成java的属性名。</p>
<p>属性可以配置两种类型。1、字面值。2、引用。下面列举这两种方式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-classic"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"John Doe"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spouse"</span> <span class="attr">ref</span>=<span class="string">"jane"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-modern"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"com.example.Person"</span></div><div class="line">        <span class="attr">p:name</span>=<span class="string">"John Doe"</span>【<span class="attr">1</span>：字面值】</div><div class="line">        <span class="attr">p:spouse-ref</span>=<span class="string">"jane"</span>/&gt;【2：引用类型】</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jane"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Jane Doe"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看到，<code>p:name=&quot;John Doe&quot;</code>使用p命名空间来定义属性值，<code>p:spouse-ref=&quot;jane&quot;</code>使用p命名空间来定义属性的引用，它等同于<code>&lt;property name=”spouse” ref=”jane”/&gt;</code>凭借-ref表明这不是直接的值而是对另一个对象的引用。</p>
<p>p命名空间并没有标准的XML形式灵活。例如，属性如果以Ref结尾则会与属性的引用冲突，标准的XML形式就不会有这样的问题。我们推荐仔细地选择自己的方式，并和团队成员交流，以避免XML文档中同时出现三种不同的方式。</p>
<h6 id="使用c命名空间简写XML"><a href="#使用c命名空间简写XML" class="headerlink" title="使用c命名空间简写XML"></a>使用c命名空间简写XML</h6><p>与使用p命名空间简写XML类似，c命名空间是Spring3.1新引入的，允许使用内联属性配置构造方法的参数，而不用嵌套constructor-arg元素。同样c命名空间也没有定义在XSD文件中（但是存在于Spring核心包中）。例子如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span>【原来xml构造方法的配置方式】</div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:bar-ref</span>=<span class="string">"bar"</span> <span class="attr">c:baz-ref</span>=<span class="string">"baz"</span> <span class="attr">c:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</span>【c命名空间】</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>对于引用类型，c: 命名空间与p: 命名空间使用一样，都通过-ref来引用bean，通过名字设置构造方法的参数。。</p>
<p>某些极少数的情况，如果没法获取构造方法参数名，那么可以使用参数的索引。如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:_0-ref</span>=<span class="string">"bar"</span> <span class="attr">c:_1-ref</span>=<span class="string">"baz"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>经过实践，构造方法的解决机制在匹配参数方面很有效率，所以除非真的需要，推荐在所有配置的地方都使用名字符号。</p>
<h6 id="合成属性名"><a href="#合成属性名" class="headerlink" title="合成属性名"></a>合成属性名</h6><p>可以使用合成或嵌套的属性名设置bean的属性，只要路径中除了最后的属性值的所有的组件都不为null，考虑使用如下bean定义：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"foo.Bar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fred.bob.sammy"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>foo有一个属性叫fred，fred有一个属性叫bob，bob有一个属性叫sammy，并且最后的sammy属性的值被设置为123。其中，foo的fred属性和fred的bob属性在bean构造后必须不为null，否则将会抛出空指针异常。</p>
<h6 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h6><p>在<code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素内部定义的bean就是所谓的内部bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>内部bean不需要定义id或name，即使指定了，容器也不会使用它作为标识符。容器在创建内部bean时也会忽略其作用域标志，内部bean总是匿名的且总是随着外部bean一起创建。不可能把内部bean注入到除封闭bean以外的合作bean，也不可能单独访问它们。</p>
<h5 id="4-4-3-使用depends-on"><a href="#4-4-3-使用depends-on" class="headerlink" title="4.4.3 使用depends-on"></a>4.4.3 使用depends-on</h5><p>如果一个bean是另一个bean的依赖，那说明这个bean是另一个bean的属性。在XML配置中使用<code>&lt;ref/&gt;</code>元素来完成这件事。但是，有时bean之间的依赖并不是直接的，例如，一个静态的初始化器需要被触发，比如在数据库驱动注册时。depends-on属性可以明确地强制一个或多个bean在使用它（们）的bean初始化之前被初始化。 </p>
<p>下面的例子使用depends-on属性表示对一个单例bean的依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>要表示对多个bean的依赖，可以为depends-on属性的值提供多个名字，使用逗号，空格或分号分割：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager,accountDao"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">ref</span>=<span class="string">"manager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>depends-on属性能够同时指定初始化时依赖和通信销毁时依赖，这只能在单例bean的情况中运用。依赖的bean在给定的bean销毁之前被销毁。因此，depends-on也能够控制关闭的顺序。（初始化的时候依赖的对象先初始化才能注入，销毁时需要依赖的对象先销毁才能解绑）。</p>
<h5 id="4-4-4-延迟初始化的bean"><a href="#4-4-4-延迟初始化的bean" class="headerlink" title="4.4.4 延迟初始化的bean"></a>4.4.4 延迟初始化的bean</h5><p>默认情况下，ApplicationContext的实现创建和配置所有单例bean作为初始化过程的一部分。通常都需要这种预初始化，因为配置或环境中的错误可以立即被发现，相反则可能需要很长时间才能发现错误。如果不需要预初始化，可以延迟初始化。延迟初始化意味着IoC容器在第一次请求到这个bean时才初始化，而不是启动的时候初始化。XML配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.AnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>当ApplicationContext使用上面的配置启动时时，名为lazy的bean并不会预初始化，而not.lazy则会预初始化。 </p>
<p>但是，当一个延迟初始化的bean是另一个非延迟初始化的单例bean的依赖时，ApplicationContext会在启动时创建这个延迟初始化的bean，因为它必须用来满足那个单例的依赖。这个延迟初始化的bean被注入到非延迟初始化的单例bean中。</p>
<p>也可以在<code>&lt;beans/&gt;</code>元素上设置其default-lazy-init属性以便在容器级别控制延迟初始化。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="4-4-5-自动装配（不建议使用）"><a href="#4-4-5-自动装配（不建议使用）" class="headerlink" title="4.4.5 自动装配（不建议使用）"></a>4.4.5 自动装配（不建议使用）</h5><p>spring IoC容器可以自动装配相互协作之间的bean，粒度可以控制到单个bean。自动装配有以下优点：</p>
<p>(1)、自动装配将极大地减少指定属性或构造方法参数的需要。</p>
<p>(2)、自动装配可以更新配置当你的对象进化时。例如，如果你需要为一个类添加一个依赖，那么不需要修改配置就可以自动满足。因此，自动装配在开发期间非常有用，但不否定在代码库变得更稳定的时候切换到显式的装配。</p>
<p>自动装配的功能有四种模式，如下所示：</p>
<p>no：（默认）不自动装配。bean的引用必须通过ref元素定义。对于大型项目，不推荐更改默认设置，因为显式地指定合作者能够更好地控制且更清晰。</p>
<p>byName：按属性名称自动装配。Spring根据属性寻找名称相同的bean。如有一个属性叫<strong><em>（它有set</em></strong>(…)方法），Spring会找到一个名叫<em>*</em>的bean并把它设置到这个属性中。</p>
<p>byType：按属性的类型自动装配。</p>
<p>(1)、必须只存在一个bean。</p>
<p>(2)、如果多个bean名字相同，会抛出异常。</p>
<p>(3)、如果一个都没有，则什么事都不会发生，这个属性不会被装配。</p>
<p>constructor：与按类型装配类似，只不过用于构造方法的参数。如果这个构造方法的参数类型在容器中不存在明确的一个bean，将会抛出异常。</p>
<h6 id="自动装配的局限性和缺点："><a href="#自动装配的局限性和缺点：" class="headerlink" title="自动装配的局限性和缺点："></a>自动装配的局限性和缺点：</h6><p>如果一个项目一直使用自动装配，它会运行得很好。如果只是用在一两个bean上，则会出现混乱。自动装配有如下局限性和缺点：</p>
<p>(1)、在property和constructor-arg上显式设置的依赖总是覆盖自动装配。而且，不能自动装配所谓的简单属性，如基本类型、String和Classes（也包括简单属性的数组）。</p>
<p>(2)、自动装配没有显式装配精确。</p>
<p>(3)、从Spring容器生成文档的工具可能找不到装配信息。</p>
<p>(4)、容器中的多个bean定义可能会匹配setter方法或构造方法参数指定的类型。对于数组、集合或Map，这未必是个问题。但是，对于那些需要单个值的依赖，这种歧义并不能随意解决。如果没有各自不同的bean定义，将会抛出异常。</p>
<p>在上述场景中，有如下几种选择：</p>
<p>(1)、放弃自动装配，改为显式地装配。</p>
<p>(2)、设置bean的autowire-candidate属性为false以避免自动装配。</p>
<p>(3)、设置<code>&lt;bean/&gt;</code>标签的primary属性为true，从而为其指定一个单独的bean作为主要的候选者。</p>
<p>避免bean自动装配：</p>
<p>(1)、单个bean：设置<code>&lt;bean&gt;</code>元素的autowire-candidate属性为false。</p>
<p>(2)、autowire-candidate属性：如果某个Bean不想被自动装配到其他的Bean中，Spring中的Bean有个autowire-candidate属性设置为false就可以达到我们的目的。</p>
<h5 id="4-4-6-方法注入"><a href="#4-4-6-方法注入" class="headerlink" title="4.4.6 方法注入"></a>4.4.6 方法注入</h5><p>在大部分情况下，容器中的bean都是singleton类型的。如果一个singleton bean要引用另外一个singleton bean，或者一个非singleton bean要引用另外一个非singleton bean时，通常情况下将一个bean定义为另一个bean的property值就可以了。不过对于具有不同生命周期的bean来说这样做就会有问题了，比如在调用一个singleton类型bean A的某个方法时，需要引用另一个非singleton（prototype）类型的bean B，对于bean A来说，容器只会创建一次，这样就没法在需要的时候每次让容器为bean A提供一个新的的bean B实例。</p>
<p>对于上面的问题Spring提供了三种解决方案： </p>
<p>(1)、放弃控制反转（不推荐）。通过实现ApplicationContextAware接口让bean A能够感知bean 容器，并且在需要的时候通过使用<code>getBean(&quot;B&quot;)</code>方式向容器请求一个新的bean B实例。</p>
<p>(2)、Lookup方法注入。Lookup方法注入利用了容器的覆盖受容器管理的bean方法的能力，从而返回指定名字的bean实例。</p>
<p>(3)、自定义方法的替代方案。该注入能使用bean的另一个方法实现去替换自定义的方法。</p>
<p>对于第一种放弃控制反转可以通过实现ApplicationContextAware接口使 A 能连接到容器，并在每次 A 需要 B 的实例的时候调用容器的<code>getBean(“B”)</code>方法取得新的 B 的实例。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</div><div class="line">        Command command = createCommand();</div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command.class);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这种方式并不推荐使用，因为业务代码跟spring耦合了。方法注入，从某种角度来看是spring IoC容器的高级特性，允许以一种干净的方式处理这种用例。</p>
<p>对于第二种Lookup方法注入，它是容器的一项能力，它可以重写容器管理的bean的方法，并返回另一个bean的查找结果。查找往往涉及到前面描述的那种原型（prototype）bean。spring利用CGLIB库动态地生成字节码子类，从而重写方法以实现查找方法注入。</p>
<p>(1)、为了能使动态的子类有效，被继承的类不能是final，且被重写的方法也不能是final。</p>
<p>(2)、单元测试一个具有抽象方法的类时，需要手动继承此类并重写其抽象方法。</p>
<p>(3)、组件扫描的具体方法也需要具体类。</p>
<p>(4)、一项关键限制是查找方法不能使用工厂方法和配置类中的@Bean方法，因为容器不会在运行时创建一个子类及其实例。</p>
<p>(5)、最后，方法注入的目标对象不能被序列化。</p>
<p>查看前面关于CommandManager类的代码片段，可以发现spring容器会动态生成createCommand()方法的实现。CommandManager不会有任何的spring依赖，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</div><div class="line">        Command command = createCommand();</div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端类包含了将被注入的方法（本例中的CommandManager），被注入的方法需要如下签名：</p>
<p><code>&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</code></p>
<p>如果方法是抽象的，动态生成的子类会实现这个方法。另外，动态生成的子类也会重写原类中的具体方法。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"command"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"command"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>commandManager这个bean会在任何它需要command实例的时候调用其<code>createCommand()</code>方法。如果实际需要，则必须把command声明为原型（prototype）。如果被声明为单例（singleton），则每次返回的都是同一个command实例。</p>
<h4 id="4-5-bean的作用域"><a href="#4-5-bean的作用域" class="headerlink" title="4.5 bean的作用域"></a>4.5 bean的作用域</h4><p>Bean的作用域以下几类：</p>
<p>singleton（单例）：（默认值），每个spring的IoC容器中只保留一份bean定义对应的实例。</p>
<p>prototype（原型）：一份bean定义对应多个实例。</p>
<p>request（请求）：依赖于Http请求的生命周期，也就是说，每个Http请求都有它自己实例。这只在web应用上下文中有效。</p>
<p>session（会话）：依赖于Http会话的生命周期。这只在web应用上下文中有效。</p>
<p>globalSession（全局会话）：依赖于全局Http会话的生命周期。典型地仅当使用在Portlet上下文中有效。这只在web应用上下文中有效。</p>
<p>application（应用）：依赖于ServletContext的生命周期。这只在web应用上下文中有效。</p>
<p>websocket    依赖于WebSocket的生命周期。这只在web应用上下文中有效。</p>
<p>下面的作用域都是可以直接使用的，也可以创建自定义作用域。</p>
<h5 id="4-5-1-单例作用域"><a href="#4-5-1-单例作用域" class="headerlink" title="4.5.1 单例作用域"></a>4.5.1 单例作用域</h5><p>一个单例bean仅共享同一个实例，并且所有的请求都只返回同一个实例。</p>
<p>也就是说，spring容器严格地只创建那个bean定义的一个实例。这个单独的实例被存储在单例bean的缓存中，并且所有后来的请求及引用都会返回这个缓存的对象。</p>
<p>在xml形式中，按如下方式定义一个单例bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="4-5-2-原型作用域"><a href="#4-5-2-原型作用域" class="headerlink" title="4.5.2 原型作用域"></a>4.5.2 原型作用域</h5><p>非单例的原型作用域的bean将会导致每次请求时都创建一个新的实例。也就是说，在这个bean被注入到另一个bean时，或通过容器的<code>getBean()</code>方法请求它时都会创建一个新的实例。如下图：</p>
<p>在xml形式中，按如下方式定义一个原型bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="4-5-3-依赖于原型bean的单例bean"><a href="#4-5-3-依赖于原型bean的单例bean" class="headerlink" title="4.5.3 依赖于原型bean的单例bean"></a>4.5.3 依赖于原型bean的单例bean</h5><p>当使用依赖于原型bean的单例bean的时候，注意依赖关系是在实例化的时候被解决的。因此，如果依赖注入一个原型bean到单例bean，一个新的原型bean会被实例化，然后注入到单例bean中。这个原型实例是唯一一个提供给这个单例bean的实例。但是，假设需要在运行时单例bean每次都获得一个新的原型bean，没有办法做到注入一个新的原型bean到单例bean，因为注入仅仅发生一次，当容器实例化单例bean的时候已经解决了它的依赖的注入。如果需要在运行时获取新的原型实例。 </p>
<h5 id="4-5-4-请求、会话、全局会话、应用及WebSocket作用域"><a href="#4-5-4-请求、会话、全局会话、应用及WebSocket作用域" class="headerlink" title="4.5.4 请求、会话、全局会话、应用及WebSocket作用域"></a>4.5.4 请求、会话、全局会话、应用及WebSocket作用域</h5><h6 id="请求作用域："><a href="#请求作用域：" class="headerlink" title="请求作用域："></a>请求作用域：</h6><p>配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.foo.LoginAction"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>spring容器为每次Http请求创建了一个新的LoginAction的实例。也就是说，loginAction的作用域是Http请求级别的。注解配置如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestScope</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="会话作用域"><a href="#会话作用域" class="headerlink" title="会话作用域"></a>会话作用域</h6><p>配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>spring容器为一个单独的Http会话创建一个新的UserPreferences实例。也就是说userPreferences的作用域是Http会话级别的。注解配置方式如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SessionScope</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="全局会话作用域"><a href="#全局会话作用域" class="headerlink" title="全局会话作用域"></a>全局会话作用域</h6><p>配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"globalSession"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>全局会话作用域与标准的Http会话作用域类似，不过它只用在基于portlet的web应用上下文中。如果在标准的Servlet应用中定义一个或多个拥有全局会话作用域的bean，那么标准的Http会话作用域将被使用，并不会报错。</p>
<h6 id="应用作用域"><a href="#应用作用域" class="headerlink" title="应用作用域"></a>应用作用域</h6><p>配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"appPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.AppPreferences"</span> <span class="attr">scope</span>=<span class="string">"application"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>这与spring的单例bean很类似，但有两种非常重要的区别：它在每个ServletContext中是单例，而不是spring的“ApplicationContext”（ApplicationContext在任何给定的web应用中可能存在多个）。注解配置如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ApplicationScope</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPreferences</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-6-bean的特性（生命周期）"><a href="#4-6-bean的特性（生命周期）" class="headerlink" title="4.6 bean的特性（生命周期）"></a>4.6 bean的特性（生命周期）</h4><p>为了与容器中bean的生命周期管理交互，可以实现Spring的InitializingBean和DisposableBean接口。容器会在初始化和销毁bean时调用前者的<code>afterPropertiesSet()</code>和后者<code>destroy()</code>方法执行相应的动作。</p>
<p>spring内部使用BeanPostProcessor的实例处理它能找到的任何回调接口并调用合适的方法。如果需要定制一些spring未提供的又可以立即使用的功能或生命周期行为，可以直接实现自己的BeanPostProcessor 。</p>
<h6 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h6><p><code>org.springframework.beans.factory.InitializingBean</code>接口允许bean的所有必要属性都被容器设置好后执行初始化操作。</p>
<p>不建议使用InitializingBean 接口，因为这样会把代码与spring耦合起来。可以使用@PostConstruct注解或在bean定义中指定初始化方法作为替代方案。在xml配置中，可以使用init-method属性指定一个无参的方法。在Java配置中，可以使用@Bean的initMethod属性。例如，下面这种方式不会与spring耦合：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种方式严格来说与下面的方式是一样的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h6><p>实现了org.springframework.beans.factory.DisposableBean接口的bean允许在包含这的容器被销毁时获取一个回调。</p>
<p>不建议使用DisposableBean回调接口，同样会把代码与spring耦合。可以使用@PreDestroy注解或在bean定义中指定销毁方法作为替代方案。在xml配置中，可以使用<bean>元素的destroy-method属性。在Java配置中，可以使用@Bean的destroyMethod属性。例如，下面这种方式不会与spring耦合：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></div></pre></td></tr></table></figure></bean></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种方式严格来说与下面是一样的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="默认的初始化和销毁方法"><a href="#默认的初始化和销毁方法" class="headerlink" title="默认的初始化和销毁方法"></a>默认的初始化和销毁方法</h6><p>当不使用spring指定的InitializingBean和DisposableBean回调接口编写初始化和销毁回调方法时，我们一般会把这些方法命名为<code>init(), initialize(), dispose()</code>等等。</p>
<p>可以配置spring容器在每个bean上自动寻找初始化和销毁的回调方法。开发者可以直接使用init()作为初始化方法而不用为每一个bean配置<code>init-method=”init”</code>了。容器会在bean创建后调用这个方法（而且，这与标准的生命周期回调是一致的）。这个特性也需要为初始化和销毁方法定义统一的命名约定。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title">BlogService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> BlogDao blogDao;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlogDao</span><span class="params">(BlogDao blogDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.blogDao = blogDao;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blogDao == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The [blogDao] property must be set."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultBlogService"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>顶级元素<code>&lt;beans/&gt;</code>上的default-init-method属性会使得spring容器自动识别bean中的init方法作为初始化回调方法。当bean创建并装配后，如果它有这个方法就会在合适的时候被调用。</p>
<p>同样地，可以配置顶级元素<code>&lt;beans/&gt;</code>上的default-destroy-method属性声明销毁的回调方法。</p>
<p>当bean存在与上述约定不一样的回调方法名称时，可以使用<code>&lt;bean/&gt;</code>元素本身的init-method和destroy-method代替默认的方法。</p>
<p>spring容器保证在bean的所有依赖都注入完毕时立马调用初始化回调方法。因此，初始化方法是调用在原生（非原生即代理）的bean引用上，这意味着AOP的拦截器还没开始生效。目标bean首先被完全创建，然后AOP代理及其拦截器链才被应用。如果目标bean与代理是分开定义的，我们甚至可以绕过代理直接与原生bean进行交互。因此，在初始化方法上应用拦截器是矛盾的，因为，这样做会把目标bean的生命周期与它的代理或拦截器耦合在一起，在直接使用原生bean时就会有很奇怪的语法。</p>
<h4 id="4-7-bean定义的继承"><a href="#4-7-bean定义的继承" class="headerlink" title="4.7 bean定义的继承"></a>4.7 bean定义的继承</h4><p>bean的定义中可以包含大量的配置信息，包括构造方法参数、属性值以及容器指定的信息，比如初始化方法、静态工厂方法名等等。子bean定义可以从父定义中继承配置信息。子定义可以重写这些值，也可以在需要的时候添加新的。使用父子定义可以少码几个字，这是模板的一种形式。</p>
<p>如果编程式地使用ApplicationContext，子定义可以使用ChildBeanDefinition类。不过大部分用户并不这样使用，而是以类似ClassPathXmlApplicationContext的形式声明式地配置。在xml中，可以使用子定义的parent属性指定父bean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></div><div class="line">        <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果没有指定子定义的class，则会使用父定义的class，不过也可以重写它。后者必须保证子定义中的class与父定义中的class兼容，即它可以接受父定义中的属性值。</p>
<p>子定义可以从父定义继承作用域、构造方法参数值、属性值以及方法，也可以为它们添加新值。任何在子定义中定义的作用域、初始化方法、销毁方法或者静态工厂方法都会覆盖父定义中的配置。</p>
<p>其余的配置总是取决于子定义：依赖、自动装配模式、依赖检查、单例、延迟初始化。</p>
<p>上面的例子中在父定义中显式地使用了abstract属性。如果父定义不指定类，那么必须显式地标记abstract属性，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></div><div class="line">        <span class="attr">parent</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>父bean不能被实例化，因为它本身并不完整，并且被显式地标记为abstract了。当一个bean被定义为abstract，则它只能用做定义子bean的模板。如果试着使用abstract的父bean，比如通过另一个bean引用它或调用<code>getBean()</code>方法获取它，都会报错。同样，容器内部的<code>preInstantiateSingletons()</code>方法也会忽略定义为abstract的bean。</p>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Manual </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL研发优化解析]]></title>
      <url>/2017/07/02/mysql/Manual-MySQL-20170702/</url>
      <content type="html"><![CDATA[<p>数据库是一个易于访问和修改的信息集合。它允许使用事务来确保数据的安全性和一致性，并能快速处理百万条以上的数据。</p>
<a id="more"></a>
<p>数据库是一个易于访问和修改的信息集合。它允许使用事务来确保数据的安全性和一致性，并能快速处理百万条以上的数据。数据库一般可以用如下图形来理解：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image1.png" alt=""></p>
<p>数据库是由多种互相交互的组件构成的。大致可以分为三层，最上层是面向用户的组件：查询管理器、数据管理器、工具包，中间层是数据库的核心实现模块，最底层是数据存储引擎。下面简单介绍一下各个模块的功能：</p>
<p><strong>查询管理器</strong></p>
<p>查询解析器（Query parser）：用于检查查询是否合法</p>
<p>查询重写器（Query rewriter）：用于预优化查询</p>
<p>查询优化器（Query optimizer）：用于优化查询</p>
<p>查询执行器（Query executor）：用于编译和执行查询</p>
<p><strong>数据管理器</strong></p>
<p>事务管理器（Transaction manager）：用于处理事务</p>
<p>缓存管理器（Cache manager）：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</p>
<p>数据访问管理器（Data access manager）：访问磁盘中的数据</p>
<p><strong>工具</strong></p>
<p>备份管理器（Backup manager）：用于保存和恢复数据。</p>
<p>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。</p>
<p>监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。</p>
<p>Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。</p>
<p><strong>核心组件</strong></p>
<p>进程管理器（process manager）：管理进程/线程池。</p>
<p>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库，所以一些数据库具备自己的网络管理器。</p>
<p>文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</p>
<p>内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。处理大容量内存需要高效的内存管理器，尤其是有很多查询同时使用内存的时候。</p>
<p>安全管理器（Security Manager）：用于对用户的验证和授权。</p>
<p>客户端管理器（Client manager）：用于管理客户端连接。</p>
<p><strong>存储引擎</strong></p>
<p>存储引擎是真正存放数据的地方，实现mysql预定义的接口，提供数据获取、管理的功能。mysql预定义了存储引擎接口，用户可以根据自己业务需求选择合适的第三方存储引擎，也可以实现自己的存储引擎。我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。</p>
<p>熟悉了mysql的组件后，我们通过一个典型的MySQL查询流程来串一下各模块之间的调用关系，具体的步骤就不细说了。查询流程图如下：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image2.png" alt=""></p>
<p>本文的目的是为了帮助开发理解数据的原理，所以本文不会讨论工具类组件。本文剩余部分，我们会集中探讨数据库的查询管理器、数据管理器以及存储引擎InnoDB。</p>
<h1 id="查询管理器"><a href="#查询管理器" class="headerlink" title="查询管理器"></a>查询管理器</h1><p>查询管理器分为查询解析器、查询优化器（查询重写器也属于优化器的一部分）、查询执行器。查询解析器的工作主要是对查询语句进行语法分析，得到一颗“语法树”，查询优化器选择一种最优的查询计划，最后查询执行器编译和执行查询。下面介绍一下查询解析器和查询优化器具体如果实现的。</p>
<h2 id="查询解析器"><a href="#查询解析器" class="headerlink" title="查询解析器"></a>查询解析器</h2><p>连接线程接收到客户端的一条查询请求后，会直接将该查询请求转交给一个专门负责解析SQL、对SQL语句进行语法分析，将SQL语句转换成按某种更利于程序识别的方式表示的语法树，这个模块就是查询解析器。</p>
<p>查询解析器的工作主要是对查询语句进行语法分析，语法分析的结果是MySql内部定义的一个树状的数据结构，称为“语法树”。“语法树”的每个结点都是以下两类之一：第一类是单个的元素，比如关键字、表或属性等的名字、常数、括号、运算符等；第二类是语法类，比如子查询等。</p>
<p>比如有如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> movieTitle</div><div class="line"><span class="keyword">FROM</span> StarsIn</div><div class="line"><span class="keyword">WHERE</span> starName <span class="keyword">IN</span> (</div><div class="line">    <span class="keyword">SELECT</span> <span class="keyword">name</span></div><div class="line">    <span class="keyword">FROM</span> MovieStar</div><div class="line">    <span class="keyword">WHERE</span> birthdate <span class="keyword">LIKE</span> <span class="string">'%1960'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>它被解析成的语法树类似于：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image3.png" alt=""></p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>查询优化分为逻辑查询优化（查询重写）和物理查询优化（查询优化）两个部分。逻辑查询优化着重对查询语句的本身进行调整优化，物理查询优化则着力于对查询语句对应的某几种可能的执行计划进行代价估算，也就是选择一种最优的查询计划，这个过程一般需要从存储引擎读取相关统计数据，是种基于现有数据进行查询代价估算的方法。</p>
<h3 id="逻辑查询优化"><a href="#逻辑查询优化" class="headerlink" title="逻辑查询优化"></a>逻辑查询优化</h3><p>逻辑查询优化主要包括以下几部分：</p>
<p><strong>视图重写</strong></p>
<p>视图重写就是将对视图的引用重写为对基本表的引用。视图重写后的SQL多被作为子查询进行进一步优化。所有的视图都可以被子查询替换。MySQL只支持对简单视图的视图重写优化。</p>
<p><strong>子查询优化</strong></p>
<p>MySQL支持使用子查询展开算法优化子查询，又称子查询反嵌套或子查询上拉。把一些子查询置于外层的父查询中，作为连接关系与外层父查询并列，其实质是把某些子查询重写为等价的多表连接操作。带来的好处是，减少表扫描次数的同时，有关的访问路径、连接方法和连接顺序可能被有效使用。MySQL支持对简单SELECT查询中的子查询优化，包括：<br>简单SELECT查询中的子查询；带有DISTINCT、ORDER BY、LIMIT操作的简单SELECT查询中的子查询。MySQL不支持对如下情况的子查询进行优化：带有UNION操作；带有GROUP BY、HAVING、聚集函数；使用ORDER BY中带有LIMIT；内表、外表的各种超过MySQL支持的最大表的连接数。</p>
<p><strong>等价谓词重写</strong></p>
<p>通过分析处理查询中的谓词，把逻辑表达式改写成等价的且效率更高的形式，能有效提高查询效率。这就是等价谓词重写。</p>
<p>等价谓词重写有很多规则和算法提供支持，MySQL对等价谓词重写优化技术的支持情况如下表所示：</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>谓词原型</th>
<th>转换后的谓词形式</th>
<th>带来的好处</th>
<th>MySQL支持情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOT规则</td>
<td>NOT(age!=8)<br>NOT(age!=sno)<br>NOT(age=sno)<br>NOT(age&lt;sno)<br>NOT(age&gt;sno)</td>
<td>(test.age=8)<br>(test.sno=test.age)<br>(test.age&lt;&gt;test.sno)<br>(test.age&gt;=test.sno)<br>(test.age&lt;=test.sno)</td>
<td>NOT规则重写的好处是，如果age列上建立了索引，则可以用索引扫描代替原来的全表扫描</td>
<td>支持</td>
</tr>
<tr>
<td>LIKE规则</td>
<td>name LIKE &#39;abc%&#39;</td>
<td>test.name &gt;= &#39;abc&#39; AND name &lt; &#39;abd&#39;</td>
<td>LIKE谓词只能进行全表扫描，如果name列上存在索引则转换后可以进行索引范围扫描</td>
<td>不支持</td>
</tr>
<tr>
<td>BETWEEN-AND规则</td>
<td>BETWEEN 10 AND 20</td>
<td>test.sno &gt;= 10 and sno &lt;=20</td>
<td>如果sno上简历了索引，则可以避免BETWEEN-AND限定的全表扫描</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>可以看出，MySQL只对NOT谓词进行了谓词重写优化，因此在编写SQL时应根据情况进行适当的SQL优化来提高执行效率。还有其他几种谓词重写优化规则，因为MySQL并不支持优化因此未全部列出。</p>
<p><strong>条件化简</strong></p>
<p>WHERE、HAVING和ON条件由许多表达式组成，而这些表达式在某些时候彼此之间存在一定的联系。利用等式和不等式的性质，可以将WHERE、HAVING和ON化简。MySQL支持的条件化简规则如下：</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>表达式原型</th>
<th>支持情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>去除表达式中冗余的括号</td>
<td>((a AND b) AND (c AND d))</td>
<td>支持</td>
</tr>
<tr>
<td>常量传递</td>
<td>name=age AND age=3</td>
<td>支持</td>
</tr>
<tr>
<td>消除死码</td>
<td>(0&gt;1 OR a=5)</td>
<td>支持</td>
</tr>
<tr>
<td>合取项只要有一个为假，即整个表达式为假</td>
<td>(0&gt;1 AND s1=5)</td>
<td>支持</td>
</tr>
<tr>
<td>AND操作符是可交换的</td>
<td>name+age=100 AND name&gt;1 AND age&gt;2</td>
<td>支持，MySQL支持对条件按表达式的连接顺序进行排序，有限判断连接的表涉及的条件</td>
</tr>
<tr>
<td>表达式计算</td>
<td>name = 1+2</td>
<td>部分支持如果操作数都是常量则能计算求值；</td>
</tr>
</tbody>
</table>
<p><strong>外连接消除</strong></p>
<p>MySQL支持外连接转换为内连接，转换的条件是内表符合“空值拒绝”。所谓“空值拒绝”一般指的是一下两种情形：条件可以保证从结果中排除外连接右侧生成的值为NULL的行（即条件确保应用在右表带有空值的对象上时，条件不满足，条件的结果值为FALSE或UNKNOWN，这样右表就不会有值为NULL的行生成），所以能使该查询在语义上等效于内连接。外连接的提供空值的一侧（可能是左侧的外表也可能是右侧的内表）为另一侧的每行只返回一行。如果该条件为真，则不存在提供空值的行，并且外连接等价于内连接。</p>
<p><strong>嵌套连接消除</strong></p>
<p>嵌套连接消除的意义在于：对嵌套连接消除为多表的直接连接，表之间的连接次序是可以交换的，这样能灵活求解不同连接方式的花费，进而得到最小花费的连接方式。而嵌套连接则不能利用交换表的位置而获得优化。</p>
<p><strong>语义优化</strong></p>
<p>MySQL通过add_not_null_conds函数，部分实现了语义优化的功能(这是通过对DDL中定义了非空的属性，而SQL查询语句中限定了IS NULL)，比如创建表的DDL中指定了name为NOT NULL，而SQL查询语句如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> s.name,s.age <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">AND</span> age &gt; <span class="number">18</span>;</div></pre></td></tr></table></figure></p>
<p>优化后的SQL为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> s.name,s.age <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p><strong>非SPJ优化</strong></p>
<p><strong>GROUP BY优化</strong>　MySQL对GROUP BY的处理通常采用的方式是扫描整个表，创建一个临时表用以执行分组操作。所以查询执行计划中出现Using temporary字样就表示MySQL采用了常规处理方式。MySQL对GROUP BY的优化方法就是尽量利用索引。利用索引的条件是：分组子句中的列对象源自同一个b树索引（不支持hash索引优化）的全部或前缀部分的部分有序的键（分组使用的索引列与索引索引简历的顺序不匹配则不能使用索引）。主要方式有松散索引扫描和严密索引扫描。这两个扫描都是以WHERE中的列对象为依据，用索引匹配，如果全部匹配上，则表示是严密索引扫描；如果部分匹配上，则表示是松散索引扫描，如果没有可以匹配的，则表示不能利用索引进行分组操作的优化。</p>
<p><strong>ORDER BY优化</strong>　所谓的ORDER BY优化其实是使用基于对索引的扫描对排序进行优化。通过扫描索引来减少扫描表带来的IO，但该优化只支持查询的目标列都是索引列的情况。</p>
<p><strong>DISTINCT优化</strong>　对于DISTINCT的优化，MySQL支持基于索引的DISTINCT优化和DISTINCT迁移的优化技术。<br>基于索引的优化同其他优化类似，都是使用基于索引的扫描来代替表扫描来减少IO从而提供性能。<br>而DISTINCT迁移的优化是指在对连接操作的结果执行DISTINCT时，可能可以把DISTINCT迁移到一个子查询中优先进行。</p>
<p><strong>LIMIT优化</strong>　MySQL支持对不带HAVING子句的LIMIT进行优化。主要优化点如下：</p>
<p>LIMIT对单表扫描的影响：如果索引扫描可用且花费低于全表扫描，则用索引扫描实现LIMIT（如果LIMIT取的行数过大，则优化器可能会使用全表扫描）。</p>
<p>LIMIT对排序的影响：如果LIMIT和ORDER BY子句一起使用，当取到LIMIT设定个数的有序元组数后，后续的排序操作将不再进行。</p>
<p>LIMIT对去重的影响：如果LIMIT和DISTINCT子句一起使用，当取到LIMIT设定个数的唯一的元组数后，后续的去重操作将不再进行。</p>
<p>LIMIT受分组的影响：如果LIMIT和GROUP BY子句一起使用，GROUP BY按索引有序计算每个组的总数的过程中，LIMIT操作不必计数直到下一个分组开始计算。</p>
<p>LIMIT 0：直接返回空结果集。</p>
<h3 id="物理查询优化"><a href="#物理查询优化" class="headerlink" title="物理查询优化"></a>物理查询优化</h3><p>物理查询优化阶段，MySQL对转变后的语法树，进一步根据代价估算模型，评估单表扫描的方式和多表连接最优的连接方式。即先对多个表的连接次序进行组合，得到多种不同的连接次序下形成的执行计划，然后用贪婪算法完成每种访问方式的代价估算。</p>
<p>查询代价估算基于CPU代价和IO代价，代价模型可表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">总代价 = IO 代价 + CPU代价，</div><div class="line">即 COST = P*a_page_cpu_time + W*T</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>P为该计划执行时可能访问的页面数，a_page_cpu_time是每个页面读取花费的时间，其乘积反映了IO代价；</li>
<li>T为访问的记录数，反映了CPU花费（访问记录需要解析记录的结构，才能把记录上的字段读出，这消耗的是cpu）。如果是索引扫描，还会包括索引读取的代价。</li>
<li>W为权重因子，表示IO到CPU的相关性，又称为选择率。选择率表示满足条件的记录数与表中总记录数的比值。需要注意的是，选择率的计算不可能全表扫描得出，一般采用数据抽样方法评估和采用数据结构提前维护属性值的一个直方图描述分布情况。</li>
</ul>
<p>特别地，对于单表扫描，在使用基于索引的扫描和全表扫描时的代价估算公式分别如下：</p>
<table>
<thead>
<tr>
<th>扫描方式</th>
<th>代价估算公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>全表扫描</td>
<td>N_page*a_tuple_IO_time + N_tuple*a_tuple_CPU_time</td>
</tr>
<tr>
<td>索引扫描</td>
<td>C_index + N_page_index * a_tuple_IO_time</td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li>a_page_IO_time, 一个页面的IO花费</li>
<li>N_page, 读取的页面数</li>
<li>N_page_index, 索引页面数</li>
<li>a_tuple_CPU_time, 一条记录从页面解析的CPU花费</li>
<li>N_tuple, 记录数</li>
<li>C_index, 索引的IO花费，C_index = N_page_index * a_page_IO_time</li>
<li>N_tuple_index, 索引作用下的记录数， N_tuple_index = N_tuple * 索引选择率</li>
</ul>
<p>从以上公式中可以看出，使用索引扫描能明显减少IO代价，索引是提高查询效率的有效手段。但是某个列上存在索引，并不意味着索引能够被使用。通常查询优化器使用索引的原则如下：<br>索引列作为条件出现在WHERE、HAVING、ON子句中，这样有利于利用索引过滤出记录；<br>索引列是被连接的表的列且存在于连接条件中；</p>
<p>除了以上两种情况，还有一些特殊情况可以使用索引，比如基于索引列的排序操作、在索引列上求MIN、MAX值等。</p>
<p>对于有索引的列，索引可用的条件总结如下：</p>
<ul>
<li><p>在<code>WHERE</code>、<code>JOIN/ON</code>、<code>HAVING</code>的条件中出现“列名 &lt;操作符>常量”格式的条件子句（索引列不能参与带有变量的表达式计算）；</p>
</li>
<li><p>操作符不能是&lt;>操作符（不等于操作符在任何类型的列上不能使用索引，可以认为这是一个优化规则，在这种情况下，顺序扫描的效果通常好于索引扫描）；</p>
</li>
<li><p>索引列的选择率越低，索引越有效，通常认为索引选择率小于0.1则索引扫描效果会更好。</p>
</li>
</ul>
<p>需要注意的是在以下情况中不一定会使用索引：</p>
<ul>
<li><p>做连接条件的记录定位不一定用索引（代价估算决定哪种扫描方式最优）；</p>
</li>
<li><p>索引在<code>WHERE</code>中出现，但是是与子查询比较，不会使用索引，比如:<code>SELECT t.t1 IN (SELECT a.a1 FROM A a);</code>其中t1是索引列；</p>
</li>
<li><p>索引列出现在<code>GROUP BY</code>子句中，而不在WHERE子句中，不触发索引扫描；</p>
</li>
</ul>
<p><strong>联合索引对索引使用的影响：</strong></p>
<p>联合索引只由多个列组合形成的组合索引，如果在WHERE子句中出现了部分索引列，但是这部分索引列不是联合索引的前缀部分，不会使用索引。例如有如下的联合索引（r1, r2, r3, r4）则有如下情形：</p>
<table>
<thead>
<tr>
<th>WHERE中出现的索引列</th>
<th>是否使用索引</th>
<th>哪些索引列起作用</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>r1, r2</td>
<td>是</td>
<td>r1, r2</td>
<td>r1, r2是r1, r2, r3, r4的前缀</td>
</tr>
<tr>
<td>r2, r3</td>
<td>否</td>
<td>-</td>
<td>r2, r3是r1, r2, r3, r4的前缀</td>
</tr>
<tr>
<td>r1, r2, r4</td>
<td>是</td>
<td>r1, r2</td>
<td>只有r1, r2是r1, r2, r3, r4的前缀</td>
</tr>
</tbody>
</table>
<p><strong>多个索引对使用的影响:</strong></p>
<ul>
<li><p><code>WHERE</code>条件中出现两个可利用的索引，优选最简单的索引；</p>
</li>
<li><p><code>WEHRE</code>条件中包含一个索引但在两个条件中出现，优选最简单的索引；</p>
</li>
<li><p>独立索引优先于联合索引；</p>
</li>
<li><p>等值比较优先于范围扫描；</p>
</li>
</ul>
<h2 id="数据管理器"><a href="#数据管理器" class="headerlink" title="数据管理器"></a>数据管理器</h2><p>数据管理器包含缓冲管理器、事务管理器以及数据访问管理器。事务管理器用于处理事务，缓存管理器负责数据被使用之前和写入磁盘之前置于内存。数据访问管理器通过定义的接口访问磁盘中的数据。这部分主要深入聊一下缓存管理器和事务管理器。</p>
<h3 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h3><p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能。缓存的操作和管理由存储引擎实现，MYSQL只定义缓存的接口。</p>
<p>缓冲只是容量有限的内存空间，因此，为了加载新的数据，它需要移除一些数据。加载和清除缓存需要一些磁盘和网络I/O的成本。如果你有个经常执行的查询，那么每次都把查询结果加载然后清除，效率就太低了。现代数据库用缓冲区置换策略来解决这个问题。</p>
<h4 id="缓冲区置换策略"><a href="#缓冲区置换策略" class="headerlink" title="缓冲区置换策略"></a>缓冲区置换策略</h4><p>多数现代数据库(至少 SQL Server, MYSQL, Oracle 和 DB2)使用 LRU 算法。LRU代表最近最少使用（Least Recently Used）算法，背后的原理是：在缓存里保留的数据是最近使用的，所以更有可能再次使用。这个算法效果很好，但是有些限制。如果对一个大表执行全表扫描怎么办？换句话说，当表/索引的大小超出缓冲区会发生什么？使用这个算法会清除之前缓存内所有的数据，而且全扫描的数据很可能只使用一次。为了解决这个问题，LRU算法产生了很多衍生的优化算法，大致原理类似，新数据不是直接插到队列头部，而是中间某个位置，当达到一定访问次数之后，才进入热数据区域。</p>
<h4 id="写缓冲区"><a href="#写缓冲区" class="headerlink" title="写缓冲区"></a>写缓冲区</h4><p>我只探讨了读缓存–在使用之前预先加载数据。缓冲区域也可以用来保存数据，然后成批刷入磁盘，而不是逐条写入数据从而造成很多单次磁盘访问。要记住，缓冲区保存的是页（最小的数据单位）而不是行（逻辑上/人类习惯的观察数据的方式）。缓冲池内的页如果被修改了但还没有写入磁盘，就是脏页。MYSQL会有另外一颗共享B+树记录脏页，当相同页的其他行数据再次修改，可以先在内存中进行Merge，MYSQL会定期（每秒和每10秒）进行刷脏，每次读取涉及脏页也会触发刷脏。</p>
<h3 id="Innodb事务管理"><a href="#Innodb事务管理" class="headerlink" title="Innodb事务管理"></a>Innodb事务管理</h3><p>事务（Transaction）是数据库区别于文件系统的重要特性之一，事务会把数据库从一种一致性状态转换为另一种一致性状态。在数据库提交时，可以确保要么所有修改都已保存，要么所有修改都不保存。事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。事务是访问并更新数据库中各种数据项的一个程序执行单元。</p>
<p>InnoDB存储引擎中的事务满足ACID的特性:</p>
<ul>
<li><p>原子性(atomicity )</p>
</li>
<li><p>一致性(consistency)</p>
</li>
<li><p>隔离性(isolation )</p>
</li>
<li><p>持久性(durability)</p>
</li>
</ul>
<h4 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h4><p>从事务理论的角度可以把事务分为以下几种类型：</p>
<ul>
<li><p>扁平事务（Flat Transactions）</p>
</li>
<li><p>带有保存节点的扁平事务（Flat Transactions with Savepoints）</p>
</li>
<li><p>链事务（Chained Transactions）</p>
</li>
<li><p>嵌套事务（Nested Transactions）</p>
</li>
<li><p>分布式事务（Distributed Transactions）</p>
</li>
</ul>
<p><strong>扁平事务</strong></p>
<p>扁平事务（Flat Transactions）是事务类型中最简单但使用最频繁的事务。在扁平事务中，所有的操作都处于同一层次，由<code>BEGIN/START TRANSACTION</code>开始事务，由<code>COMMIT/ROLLBACK</code>结束，且都是原子的，要么都执行，要么都回滚。因此扁平事务是应用程序成为原子操作的基本组成模块。</p>
<p>扁平事务的主要限制是不能提交或者回滚事务的某一部分。如果某一事务中有多个操作，在一个操作有异常时并不希望之的操作全部回滚，而是保存前面操作的更改。扁平事务并不能支持这样的事例，因此就出现了带有保存节点的扁平事务。</p>
<p><strong>带有保存节点的扁平事务</strong></p>
<p>带有保存节点的扁平事务（Flat Transactions with Savepoints）允许事务在执行过程中回滚到较早的一个状态，而不是回滚所有的操作。保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。对于扁平事务来说，在事务开始时隐式地设置了一个保存点，回滚时只能回滚到事务开始时的状态。</p>
<p><strong>链事务</strong></p>
<p>链事务（Chained Transaction）是指一个事务由多个子事务链式组成。前一个子事务的提交操作和下一个子事务的开始操作合并成一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。这样，在提交子事务时就可以释放不需要的数据对象，而不必等到整个事务完成后才释放。</p>
<p>链事务与带保存节点的扁平事务不同的是，链事务中的回滚仅限于当前事务，相当于只能恢复到最近的一个保存节点，而带保存节点的扁平事务能回滚到任意正确的保存点。但是，带有保存节点的扁平事务中的保存点是易失的，当发生系统崩溃是，所有的保存点都将消失，这意味着当进行恢复时，事务需要从开始处重新执行。</p>
<p><strong>嵌套事务</strong></p>
<p>嵌套事务（Nested Transaction）是一个层次结构框架。由一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务成为子事务（subtransaction）,其控制着每一个局部的操作，子事务本身也可以是嵌套事务。因此，嵌套事务的层次结构可以看成是一颗树，其结构如下图所示：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image4.png" alt=""></p>
<p><strong>分布式事务</strong></p>
<p>分布式事务（Distributed Transactions）通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中不同节点的数据库资源。</p>
<h4 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h4><p>redo log（重做日志）用来保证事务的持久性。undo log用来保证事务的原子性和MVCC。锁机制来保证事务的隔离性。</p>
<p>redo和undo的作用都可以视为是一种恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。因此两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。</p>
<p><strong>redo 日志</strong></p>
<p>重做日志用来实现事务的持久性，即事务ACID中的D。其由两部分组成:一是内存中的重做日志缓冲(redo log buffer，其是易失的；二是重做日志文件(redo log file其是持久的。</p>
<p>InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交(COMMIT)时，必须先将该事务的所有日志写人到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。</p>
<p>redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写人重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作。由于重做日志文件打开并没有使用o_DIRECT选项，因此重做日志缓冲先写入文件系统缓存。为了确保重做日志写入磁盘，必须进行一次fsync操作。由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。</p>
<p>InnoDB存储引擎允许用户手工设置非持久性的情况发生，以此提高数据库的性能。即当事务提交时，日志不写入重做日志文件，而是等待一个时间周期后再执行fsync操作。由于并非强制在事务提交时进行一次fsync操作，显然这可以显著提高数据库的性能。但是当数据库发生宕机时，由于部分日志未刷新到磁盘，因此会丢失最后一段时间的事务。</p>
<p>参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。该参数的默认值为1，表示事务提交.时必须调用一次fcync操作。还可以设置该参数的值为0和2。0表示事务提交时不进行写入重做日志操作，这个操作仅在maser thread中完成，而在master thread中每1秒会进行一次重做日志文件的fsync操作。2表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。在这个设置下，当MySQL数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。</p>
<p><strong>undo 日志</strong></p>
<p>重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p>
<p>redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段(segment)中，这个段称为undo段(undo segment ) 。undo段位于共享表空间内。</p>
<p>用户通常对undo有这样的误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子–但事实并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>
<p>例如，用户执行了一个<code>INSERT</code>10W条记录的事务，这个事务会导致分配一个新的段，即表空间会增大。在用户执行<code>ROLLBACK</code>时，会将插入的事务进行回滚，但是表空间的大小并不会因此而收缩。因此，当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个<code>INSERT</code>,  InnoDB存储引擎会完成一个<code>DELETE</code>；对于每个<code>DELETE</code>，InnoDB存储引擎会执行一个<code>INSERT</code>；对于每个<code>UPDATE</code>，InnoDB存储引擎会执行一个相反的<code>UPDATE</code>，将修改前的行放回去。</p>
<p>除了回滚操作，undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p>
<p>最后也是最为重要的一点是，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>SQL标准定义的四个隔离级别为:</p>
<ul>
<li><p>READ UNCOMMITTED</p>
</li>
<li><p>READ COMMITTED</p>
</li>
<li><p>REPEATABLE READ</p>
</li>
<li><p>SERIALIZABLE</p>
</li>
</ul>
<p><strong>Read Uncommitted（读取未提交内容）</strong></p>
<p>   在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。脏页是因为数据库实例内存和磁盘的异步造成的，这并不影响数据的一致性(或者说两者最终会达到一致性，即当脏页都刷回到磁盘)。并且因为脏页的刷新是异步的，不影响数据库的可用性，因此可以带来性能的提高。</p>
<p><strong>Read Committed（读取提交内容）</strong></p>
<p> 　 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read）。不可重复读是指在一个事务内多次读取同一数据集合，在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作，因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。</p>
<p>不可重复读和脏读的区别是:脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求。一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题。因此，很多数据库厂商(如Oracle, Microsoft SQL Server) 将其数据库事务的默认隔离级别设置为READ COMMITTED，在这种隔离级别下允许不可重复读的现象。</p>
<p><strong>Repeatable Read（可重读）</strong></p>
<p> 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.</p>
<p><strong>Serializable（可串行化）</strong></p>
<p> 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上锁。在这个级别，可能导致大量的超时现象和锁竞争。<br>√: 可能出现    ×: 不会出现</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong><br>幻读的问题理应由更高的隔离级别来解决，但MySQL和其它数据不一样，它同样在可重复读的隔离级别解决了这个问题。也就是说, MySQL的可重复读的隔离级别解决了”不可重复读” 和 “幻读” 2个问题，其中“幻读”需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-keylocks。MySQL默认的隔离级别也是: REPEATABLE READ(可重复读)。下面我们来看InnoDB如何通过锁机制解决以上问题：</p>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。InnoDB存储引擎会在行级别上对表数据上锁，这固然不错。不过InnoDB存储引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保证一致性，必须有锁的介人。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</p>
<p><strong>锁的类型</strong></p>
<p>InnoDB存储引擎实现了如下两种标准的行级锁:</p>
<ul>
<li>共享锁((S Lock)，允许事务读一行数据。</li>
<li>排他锁(X Lock)，允许事务删除或更新一行数据。</li>
</ul>
<p>如果一个事务T1已经获得了行t的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容(Lock Compatible)。但若有其他的事务T3想获得行r的排他锁，则其必须等待事务T1, T2释放行r上的共享锁—这种情况称为锁不兼容。下表显示了共享锁和排他锁的兼容性。</p>
<p><strong>排他锁和共享锁的兼容性:</strong></p>
<p>从上表可以发现X锁与任何的锁都不兼容，而S锁仅和S锁兼容。需要特别注意的是，S和x锁都是行锁，兼容是指对同一记录(row)锁的兼容性情况。此外，InnoDB存储引擎支持多粒度(granular)锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁(Intention Lock )。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度(fine granularity)上进行加锁。若将上锁的对象看成一棵树，那么对最下层的对象上锁，进行上锁，行上X锁，那么首先需要对粗粒度的对象上锁。也就是对最细粒度的对象如果需要对页上的记录r进 那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上x锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表i上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<p>InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁:</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下标所示。<br>Innodb存储引擎中锁的兼容性</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>SELECT * FROM t WHERE a=5 FOR UPDATE;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>INSERT INTO t SELECT 4;</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>COMMIT;</td>
</tr>
<tr>
<td>6</td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<h4 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h4><p>在并发读写数据库时，为了避免出现读操作出现不一致的情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。由于，加锁会将读写操作串行化，所以不会出现不一致的状态。但是，读操作会被写操作阻塞，大幅降低读性能。为了提高性能，解决并发访问的问题，InnoDB使用MVCC（Multi-Version Concurrent Control，即多版本并发控制）来解决这个问题。<br>在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>可以看到，非锁定读机制极大地提高了数据库的并发性。在InnoDB存储引擎的默认设置下，这是默认的读取方式，即读取不会占用和等待表上的锁。但是在READ COMMITTED事务隔离级别下，快照数据读取的是被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，快照数据读取的是事务开始时的行数据版本。</p>
<p>在事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作是不需要加锁的。但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读(locking read )操作:</p>
<ul>
<li>SELECT…FOR UPDATE</li>
<li>SELECT…LOCK IN SHARE MODE</li>
<li>SELECT FOR UPDATE对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。SELECT…LOCK IN SNARE MODE对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</li>
</ul>
<p>结论：当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事务就等待锁释放。</p>
<p> 对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。</p>
<p> 共享锁：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> .....lock <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></div></pre></td></tr></table></figure></p>
<p>排他锁：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> .....for <span class="keyword">update</span></div></pre></td></tr></table></figure></p>
<p><strong>锁的算法</strong></p>
<p>行锁的3种算法</p>
<p>InnoDB存储引擎有3种行锁的算法，其分别是:</p>
<ul>
<li>Record Lock:单个行记录上的锁</li>
<li>Gap Lock:间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock:Gap Lock+Record Lock锁定一个范围，并且锁定记录本身</li>
</ul>
<p>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</p>
<p>Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。例如一个索引有10,11,13和20这四个值，那么该索引可能被Next-Key Locking的区间为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(-∞，10]</div><div class="line">(10，11]</div><div class="line">(11，13]</div><div class="line">(13，20]</div><div class="line">(20，+∞)</div></pre></td></tr></table></figure>
<p>若事务T1已经通过next-key locking 锁定了如下范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">（10,11）、(11，13)</div></pre></td></tr></table></figure>
<p>当插入新的记录12时，则锁定的范围会变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">（10,11）、(11，12) 、(12，13)</div></pre></td></tr></table></figure></p>
<p>然而，当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。例如，根据代码创建表t:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> t;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(a <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> <span class="number">1</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> <span class="number">2</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>接着执行下表中的sql语句</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>SELECT * FROM t WHERE a=5 FOR UPDATE;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>INSERT INTO t SELECT 4;</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>COMMIT;</td>
</tr>
<tr>
<td>6</td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>表t共有1, 2, 5三个值。在上面的例子中，在会话A中首先对a=5进行X锁定。而由于a是主键且唯一，因此锁定的仅是5这个值，而不是(2,5)这个范围，这样在会话B中插入值4而不会阻塞，可以立即插人并返回。即锁定由Next-Key Lock算法降级为了Record Lock，从而提高应用的并发性。<br>Next-Key Lock降级为Record Lock仅在查询的列是唯一索引情况下。若是辅助索引，则情况会完全不同。同样，首先根据如下代码创建测试表z:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> z(a <span class="built_in">INT</span>, b <span class="built_in">INT</span>,PRIMARY <span class="keyword">KEY</span>(a), <span class="keyword">KEY</span>(b));</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</div></pre></td></tr></table></figure></p>
<p>表z的列b是辅助索引，若在会话A中执行下面sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure>
<p>很明显，这时SQL语句通过索引列b进行查询，因此其使用传统的Next-Key Locking技术加锁，并且由于有两个索引，其需要分别进行锁定。对于聚集索引，其仅对列a等于5的索引加上Record Lock。而对于辅助索引，其加上的是Next-Key Lock. 锁定的范围是(1, 3]，特别需要注意的是，InnoDB存储引擎还会对辅助索引下一个键值加上gap lock，即还有一个辅助索引范围为(3,6]的锁。因此，若在新会话B中运行下面的SQL语句，都会被阻塞:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> a=<span class="number">5</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>第一个SQL语句不能执行，因为在会话A中执行的SQL语句已经对聚集索引中列a=5的值加上X锁，因此执行会被阻塞。第二个SQL语句，主键插入4，没有问题，但是插入的辅助索引值2在锁定的范围(1,3]中，因此执行同样会被阻塞。第三个SQL语句，插入的主键6没有被锁定，5也不在范围(1, 3)之间。.但插入的值5在另一个锁定的范围(3 ,6]中，故同样需要等待。而下面的SQL语句，不会被阻塞，可以立即执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">8</span>,<span class="number">6</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">0</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">7</span>;</div></pre></td></tr></table></figure>
<p>从上面的例子中可以看到，Gap Lock的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致Phantom Problem问题的产生。例如在上面的例子中，会话A中用户已经锁定了b=3的记录。若此时没有Gap Lock锁定(3,  6)，那么用户可以插人索引b列为3的记录，这会导致会话A中的用户再次执行同样查询时会返回不同的记录，即导致Phantom Problem问题的产生。用户可以通过以下两种方式来显式地关闭Gap Lock:将事务的隔离级别设置为READ COMMITTED；将参数innodb_locks_unsafese_for_binlog设置为1。</p>
<p>在上述的配置下，除了外键约束和唯一性检查依然需要的Gap Lock，其余情况仅使用Record Lock进行锁定。但需要牢记的是，上述设置破坏了事务的隔离性，并且对于replication，可能会导致主从数据的不一致。此外，从性能上来看，READ COMMITTED也不会优于默认的事务隔离级别READ REPEATABLE.</p>
<p>在InnoDB存储引擎中，对于INSERT的操作，其会检查插人记录的下一条记录是否被锁定，若已经被锁定，则不允许查询。对于上面的例子，会话A已经锁定了表Z中b=3的记录，即已经锁定了(1, 3)的范围，这时若在其他会话中进行如下的插人同样会导致阻塞:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>因为在辅助索引列b上插人值为2的记录时，会监测到下一个记录3已经被索引。而将插入修改为如下的值，可以立即执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>最后需再次提醒的是，对于唯一键值的锁定，Next-Key Lock降级为Record Lock仅存在于查询所有的唯一索引列。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是point类型查询，故InnoDB存储引擎依然使用Next-Key Lock进行锁定。<br>锁选择</p>
<p>sql语句会根据查询计划（where条件和索引）来决定加何种类型的锁。如果更新条件没有走索引，进行全表扫描，扫表的时候，要阻止其他任何的更新操作，所以上升为表锁。如果更新条件为索引字段，但是并非唯一索引（包括主键索引），那么此时更新会使用Next-Key Lock。使用Next-Key Lock的原因：首先要保证在符合条件的记录上加上排他锁，会锁定当前非唯一索引和对应的主键索引的值；还要保证锁定的区间不能插入新的数据。如果更新条件为唯一索引，则使用Record Lock（记录锁）。</p>
<h3 id="死锁与检测"><a href="#死锁与检测" class="headerlink" title="死锁与检测"></a>死锁与检测</h3><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阂值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。在InnoDB存储引擎中，参数innodb_lock_wait_timeout用来设置超时的时间。超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据FIFO的顺序选择回滚对象。但若超时的事务所占权重比较大，如事务操作更新了很多行，占用了较多的undo log，这时采用FIFO的方式，就显得不合适了，因为回滚这个事务的时间相对另一个事务所占用的时间可能会很多。</p>
<p>因此，除了超时机制，当前数据库还都普遍采用wait-for graph(等待图)的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用的这种方式。wait-for graph要求数据库保存以下两种信息:</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在wait-for graph中，事务为图中的节点。而在图中，事务T1指向T2边的定义为:</p>
<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li>
</ul>
<p>下面来看一个例子，当前事务和锁的状态下图所示：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image5.png" alt=""></p>
<p>在Transaction Wait Lists中可以看到共有4个事务t1. t2, t3, t4，故在wait-for graph中应有4个节点。而事务t2对row 1占用X锁，事务t1对row2占用s锁。事务t1需要等待事务t2中row 1的资源，因此在wait-for graph中有条边从节点tt指向节点t2。事务t2需要等待事务t1 . t4所占用的row2对象，故而存在节点t2到节点t1, t4的边。同样，存在节点t3到节点t1. t2. t4的边，因此最终的wait-for graph如下图所示。</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image6.png" alt=""></p>
<p>通过上图可以发现存在回路(tl，t2)，因此存在死锁。通过上述的介绍，可以发现wait-for graph是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</p>
<p>在InnoDB中，使用行锁机制，于是，锁通常是逐步获得的，这就决定了在InnoDB中发生死锁是可能的。</p>
<p>死锁产生的四要素(跟操作系统的死锁条件一样)：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用；</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；</li>
<li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<pre><code>死锁的形式是多样的，但分析到innodb加锁情况的最底层，因循环等待条件而产生的死锁只有可能是四种形式：
</code></pre></li>
<li>两张表两行记录交叉申请互斥锁；</li>
<li>同一张表则存在主键索引锁冲突；</li>
<li>主键索引锁与非聚簇索引锁冲突；</li>
<li><p>锁升级导致的锁等待队列阻塞。</p>
<pre><code>一些发生死锁的情况：
</code></pre></li>
</ul>
<ol>
<li>同一索引上,两个session相反的顺序加锁多行记录；</li>
<li>Primary key和Secondary index，通过primary key找到记录，更新Secondary index字段与通过Secondary index更新记录；</li>
<li>UPDATE/DELETE通过不同的二级索引更新多条记录,可能造成在Primary key上不同的加锁顺序；</li>
</ol>
<p>Innodb检测死锁有两种策略：超时和等待图。但是在我们开发中以单个SQL语句组成的隐式事务来说，建议的避免死锁的方法如下：      1.如果使用insert…select语句备份表格且数据量较大，在单独的时间点操作，避免与其他sql语句争夺资源，或使用select into outfile加上load data infile代替 insert…select，这样不仅快，而且不会要求锁定      2. 一个锁定记录集的事务，其操作结果集应尽量简短，以免一次占用太多资源，与其他事务处理的记录冲突。      3.更新或者删除表格数据，sql语句的where条件都是主键或都是索引，避免两种情况交叉，造成死锁。对于where子句较复杂的情况，将其单独通过sql得到后，再在更新语句中使用。      4. sql语句的嵌套表格不要太多，能拆分就拆分，避免占有资源同时等待资源，导致与其他事务冲突。      5. 对定点运行脚本的情况，避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句。      6.应用程序中增加对死锁的判断，如果事务意外结束，重新运行该事务，减少对功能的影响。</p>
<h2 id="mysql存储引擎"><a href="#mysql存储引擎" class="headerlink" title="mysql存储引擎"></a>mysql存储引擎</h2><p>由于mysql开源的特性，mysql预定义了存储引擎接口，用户可以根据自己业务需求选择合适的第三方存储引擎，也可以实现自己的存储引擎。这个也是mysql区别于oracle的一个主要特性。Innodb存储引擎是其中应用最为广泛的OLTP（在线事务处理）存储引擎。下面简单介绍一下常用的mysql存储引擎。</p>
<p>innodb存储引擎，特点支持外键、行锁、非锁定读(默认情况下读取不会产生锁)、mysql-4.1开始支持每个innodb引擎的表单独放到一个表空间里。innodb通过使用MVCC来获取高并发性，并且实现sql标准的4种隔离级别，同时使用一种被称成next-key locking的策略来避免换读(phantom)现象。除此之外innodb引擎还提供了插入缓存(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能技术。</p>
<p>myisam存储引擎，myisam特点是不支持事务，适合OLAP（在线分析处理）应用，myisam表由MYD和MYI组成。mysql-5.0版本之前，myisam默认支持的表大小为4G，从mysql-5.0以后，myisam默认支持256T的表单数据。myisam只缓存索引数据。</p>
<p>NDB存储引擎，特点是数据放在内存中，mysql-5.1版本开始可以将非索引数据放到磁盘上。NDB之前的缺陷是join查询是mysql数据库层完成的，而不是存储引擎完成的，复杂的join查询需要巨大的网络开销，速度很慢。当前mysql cluster7.2版本中已经解决此问题，join查询效率提高了70倍。</p>
<p>memeory存储引擎，将数据放到内存中，默认使用hash索引，不支持text和blob类型，varchara是按照char的方式来存储的。mysql数据库使用memory存储引擎作为临时表还存储中间结果集(intermediate result)，如果中间集结果大于memorg表的容量设置，又或者中间结果集包含text和blog列类型字段，则mysql会把他们转换到myisam存储引擎表而放到磁盘上，会对查询产生性能影响。</p>
<p>archive存储引擎，压缩能力较强，主要用于归档存储。</p>
<p>下面这张表列出了MySQL中5种常用的存储引擎以及它们支持的特性。
　</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>MyISAM</th>
<th>Memory</th>
<th>InnoDB</th>
<th>Archive</th>
<th>NDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>Storage limits</td>
<td>256TB</td>
<td>Yes</td>
<td>64TB</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Transactions</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Locking granularity</td>
<td>Table</td>
<td>Table</td>
<td>Row</td>
<td>Row</td>
<td>Row</td>
</tr>
<tr>
<td>MVCC (snapshot read)</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Geospatial support</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>B-tree indexes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Hash indexes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Full-text search indexes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Clustered indexes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Data caches</td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Index caches</td>
<td>Yes</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Compressed data</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Encrypted data</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Cluster database support</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Replication support</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Foreign key support</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Backup / point-in-time recovery</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Query cache support</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Update statistics for data dictionary</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>使用mysql绝大多数场景都是使用innodb，目前innodb也是mysql的默认引擎，以下将从引擎架构、文件、表、索引四个方面介绍innodb。</p>
<h3 id="innodb引擎架构"><a href="#innodb引擎架构" class="headerlink" title="innodb引擎架构"></a>innodb引擎架构</h3><p>InnoDB体系架构图如下：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image7.png" alt=""></p>
<h4 id="后台线程简介"><a href="#后台线程简介" class="headerlink" title="后台线程简介"></a>后台线程简介</h4><ol>
<li>Master Thread：Master Thread 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、回滚页（UNDO PAGE）的回收等。</li>
<li>IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理IO请求，这样可以极大提高数据库的性能。而IO Thread（insert buffer thread、log thread、read thread、write thread）的工作主要是负责这些IO请求的回调（call back）处理。</li>
<li>Purge Thread：事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。</li>
<li>Page Cleaner Thread：Page Cleaner Thread是在InnoDB 1.2.x版本中引人的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</li>
</ol>
<h4 id="InnoDB内存数据对象简介"><a href="#InnoDB内存数据对象简介" class="headerlink" title="InnoDB内存数据对象简介"></a>InnoDB内存数据对象简介</h4><p>在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。缓冲池简单来说就是一块内存区域。在数据库中进行读取页的操作，首先将从磁盘读到的页存放到缓冲池中，这个过程称为将页”FIX”在缓冲池。下一次在读到相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。</p>
<p>为了避免发生数据丢失的问题，当前事务数据库系统普遍使用WAL（Write Ahead Log）策略，即当事务提交时，先写重做日志，再写修改页。当数据库发生宕机而导致丢失数据时，可以通过重做日志来完成数据的恢复，从而满足事务ACID中Durability持久性的要求。CheckPoint技术是为了缩短恢复时间而对持久到硬盘的数据页设置检查点，只需要对CheckPoint之后的重做日志进行恢复。CheckPoint的触发条件：1）Master Thread每秒或者每10秒会进行一次刷脏；2）当LRU中少于100个空闲页时；3）重做日志是一块循环使用的空间（8M），重做日志不可用时会触发；4）当脏页太多时，达到某个阈值。<br>InnoDB内存数据对象：数据页（undo page）、索引页（index page）、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、锁信息（lock info）、数据字典信息（data dictionary）、重做日志缓冲（redo log_buffer）、额外内存池（innodb_additional_mem_pool_size）。</p>
<p>数据库是一种基于磁盘存储系统，存储的数据量远大于内存的大小，故内存中的数据存在置换，数据库中的缓存池是通过LRU算法进行管理的。缓存池中的最小单元是页（一个页的默认大小是16kb）。Innodb对LRU进行了优化，默认配置下，新访问的数据是放到LRU列表的5/8处（防止遍历等导致常用的数据别刷出LRU列表），当达到一定时间后，才会被放入LRU的热端。</p>
<p><strong>重做日志缓冲</strong></p>
<p>重做日志缓冲是用于存放重做日志信息的，重做日志缓冲一般不需要设置的很大，因为一般情况下每一秒会将重做日志缓冲刷新到日志中去，默认大小是8M，重做日志在以下三种情况下会刷新到重做日志文件中去：1）Master Thread每一秒将重做日志缓冲刷新到重做日志文件；2）每个事物提交时会将重做日志缓冲刷新到重做日志；3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志。</p>
<p><strong>插入缓存</strong></p>
<p>在InnoDB存储引擎中，主键是行唯一的标识符。通常应用程序中行记录的插入是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要磁盘的随机读取。当一个表有非聚集索引时，对于非聚集索引的叶子节点的插入不是顺序的，这时候需要离散的访问非聚集索引页，性能就在这里降低了，这是由于B+树的原理导致的。插入缓存就是用来解决这个问题的。<br>对于非聚集索引的插入和更新操作，不是每一次都直接插入索引页，而是先判断插入的非聚集索引页是否在缓存中，如果在就直接插入，如果不在就放入到一个插入缓冲区中，好似欺骗数据库这个非聚集索引已经插入到叶子节点了。然后再以一定的频率插入缓存和非聚集索引页字节点的合并操作。插入缓存的使用需要满足以下两个条件(也就是非唯一的辅助索引)：索引是辅助索引；索引不是唯一的。插入索引自身也是一颗B+树，全局所有的表共享这颗树，这颗树存放在共享表空间。非叶结点存放的是表数据页的偏移量信息，叶子结点存放表数据页信息偏移量+非聚集索引页记录。</p>
<p>关于插入缓存什么时候合并到真正的辅助索引页，合并插入索引在以下三种情况下发生。1）辅助索引页被读取到缓冲池时，当执行select操作时，这时会检查插入缓冲Bitmap页，当确认辅助索引页有记录在插入缓冲中，则将插入缓冲中的记录插入到辅助索引页中；2）插入缓冲Bitmap页追踪到辅助索引页可用空间小于1/32，会强制进行一次合并。3）Master Thread每秒或者每10秒会进行一次插入缓冲合并到辅助索引页。</p>
<p><strong>自适应哈希索引</strong></p>
<p>由于innodb不支持hash索引，但是在某些情况下hash索引的效率很高，于是出现了 adaptive hash index功能，innodb存储引擎会监控对表上索引的查找，如果观察到建立hash索引可以提高性能的时候，则自动建立hash索引。</p>
<p><strong>双写</strong></p>
<p>重做日志结合doublewrite来保证写入的持久性。两次写给innodb带来的是可靠性，主要用来解决部分写失败(partial page write)。在应用重做日志之前，我们需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。<br>Doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2M，另外一部分就是物理磁盘上的共享表空间中连续的128个页，即两个区，大小同样为2M。当缓冲池的脏页有刷新时，并不直接写硬盘，而是会通过memcpy函数将脏页先拷贝到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次写，每次写入1M到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Mysql 数据库的文件包括以下6中类型文件：</p>
<p>√ 参数文件：my.cnf<br><br>√ 日志文件，包括错误日志、查询日志、慢查询日志、二进制日志<br><br>√ Mysql表结构文件：用来存放mysql表结构的文件，一般以.frm为后缀<br><br>√ Socket文件：当用unix域套接字方式进行连接时需要的文件<br><br>√ Pid文件：mysql实例的进程ID文件<br><br>√ innodb存储引擎文件：每个存储引擎都有自己的文件夹来保存各种数据，这些存储引擎真正存储了数据和索引等数据。</p>
<h4 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h4><p>当MySQL示例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数，这些参数通常定义了某种内存结构有多大等。在默认情况下，MySQL实例会按照一定的顺序在指定的位置进行读取，可以通过命令mysql –help | grep my.cnf来寻找。如果启动时没有找到参数文件，这时所有的参数值取决于编译MySQL时指定的默认值和源代码中指定参数的默认值。（Oracle数据库启动时，如果找不到参数文件，是不能进行装载操作的。）<br>可以通过show variables like ‘innodb_buffer%’命令查看数据库所有参数，也可以通过查看information_schema架构下的GLOBAL_VARIABLES视图进行查找（不建议）。<br>参数类型分为动态参数和静态参数，动态参数可以在MySQL实例运行中进行更改，静态参数不能更改。可以通过SET | [global | session] system_var_name = expr | [@@global. | @@session. | @@] system_var_name = expr来更改</p>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>日志文件记录了影响MySQL数据库的各种类型活动，包括：</p>
<ul>
<li>错误日志</li>
<li>二进制日志</li>
<li>慢查询日志</li>
<li>查询日志</li>
</ul>
<p><strong>错误日志（error log）</strong></p>
<p>对MySQL的启动、运行、关闭过程进行了记录。文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令<code>show variables like &#39;log_error&#39;</code>定位该文件。</p>
<p><strong>慢查询日志（slow log）</strong></p>
<p>慢查询日志可以帮助DBA定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。例如，可以在MySQL启动时设置一个阈值，将运行时间超过该值得所有SQL语句都记录到慢查询日志文件中。通过参数long_query_time来设置，默认值为10，代表10秒。如果运行的SQL没有使用索引，则MySQL数据库同样会将SQL语句记录到慢查询日志文件。MySQL 5.6.5版本开始新增参数log_throttle_queries_not_using_indexs，用来表示每分钟允许记录到show log的且未使用索引的SQL语句次数。该值默认为0，表示没有限制。</p>
<p><strong>查询日志</strong></p>
<p>查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否正确执行。默认文件名为：主机名.log。查询日志从MySQL 5.1开始也支持放入mysql架构下的general_log表中。</p>
<p><strong>二进制日志</strong></p>
<p>二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括select和show这里操作，因为这类操作对数据库本身没有修改。然而，若操作本身没有导致数据库发生变化，那么该操作可能也会写入二进制日志。<br>二进制日志的几个作用：</p>
<p><strong>恢复：</strong><br>某些数据的恢复需要二进制日志，例如，在一个数据库全备份文件恢复后，用户可以通过二进制日志进行point_in_time的恢复。</p>
<p><strong>复制：</strong><br>通过复制和执行二进制日志使一台运行的MySQL数据库与一台MySQL数据库进行实时同步。</p>
<p><strong>审计：</strong><br>用户可以通过二进制日志中的信息来进行审计，判断是否对数据库进行注入的攻击。<br>可以通过参数binlog_format配置二进制存储的格式。在使用恢复和复制同步时，有不同的效果。</p>
<h4 id="Socket文件"><a href="#Socket文件" class="headerlink" title="Socket文件"></a>Socket文件</h4><p>在UNIX系统下本地连接MySQL可以采用UNIX域套接字方式，这种方式需要一个套接字文件。<code>show variables like &#39;socket&#39;\G;</code>命名可以查看套接字文件。</p>
<h4 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h4><p>当MySQL实例启动时，会将自己的进程ID写入一个文件中——该文件即为pid文件。由参数pid_file控制。</p>
<h4 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h4><p>因为MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储时根据表进行的，每个表都会有与之对应的文件。但是不论采用何种存储引擎，MySQL都有一个以frm为后缀名的文件，这个文件记录了该表的表结构定义，还用来记录视图的定义。</p>
<h4 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h4><p><strong>表空间文件</strong></p>
<p>InnoDB采用将存储的数据按表空间进行存放的设计。在默认配置下会有一个初始化大小为10MB，名为ibdata1的文件。该文件就是默认的表空间文件（共享表空间），可以通过参数innodb_data_file_path设置。设置innodb_data_file_path参数后，所有基于InnoDB存储引擎的表数据都会记录到该共享表空间中。若设置参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立表空间。独立表空间的命名规则为：表名.idb。需要注意：独立的表空间文件仅存储该表的数据，索引和插入缓冲BITMAP等信息，其余信息还是存放在默认表空间中。</p>
<p><strong>重做日志文件</strong></p>
<p>在默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。每个InnoDB存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志文件。影响重做日志文件的属性有：innodb_log_file_size指定每个重做日志文件的大小；innodb_log_files_in_group指定了日志文件组中重做日志文件的数量，默认为2； innodb_mirrored_log_groups指定了日志镜像文件组的数量，默认为1，表示只有一个文件组，没有镜像； innodb_log_group_home_dir指定了日志文件所在路径，默认为./，表示在MySQL数据库的数据目录下。</p>
<h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p>在innoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式存储的表称为索引组织表，数据即索引，索引即数据，B+树的叶子结点即为就是数据段，非叶子结点即为索引段。每张表都会有主键，如果用户没有指定，会找第一个非空唯一健，如果没有，innodb会长生一个6字节大小的指针。</p>
<p>所有的数据都被逻辑存放在一个空间中，称之为表空间，表空间由段、区、页组成。Innodb引擎有一个共享表空间ibdata1，即所有的数据都存放在这个表空间内。如果用户启动了innodb_file_per_table，表内的数据都可以单独放到一个表空间，每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页。表空间常见的段有数据段、索引段、回滚段等。区为连续页组成的空间，区的大小为1M（即64个页）。页在也是我们常说的数据块。在InnoDB存储引擎中，常见的页类型有：数据页、undo页、系统页、事务页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页等。页盘管理的最小单位，下面是InnoDB的表空间结构图：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image8.jpg" alt=""></p>
<p>Page页面存储格式如下图所示：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image9.jpg" alt=""></p>
<p>一个页面的存储由以下几部分组成：</p>
<ol>
<li>页头（Page Header）：记录页面的控制信息，共占56字节，包括页的左右兄弟页面指针、页面空间使用情况等。</li>
<li>最小虚记录、最大虚记录：两个固定位置存储的虚记录，本身并不存储数据。最小虚记录比任何记录主键都小，而最大虚记录比任何记录主键都大。</li>
<li>记录堆（record heap）：指上图的橙黄色部分。表示页面已分配的记录空间，也是索引数据的真正存储区域，存储行记录的数据。记录堆分为两种，即有效记录和已删除记录。有效记录就是索引正常使用的记录，而已删除记录表示索引已经删除，不在使用的记录，如上图的深蓝色部分。随着记录的更新和删除越来越频繁，记录堆中已删除记录将会越多，即会出现越来越多的空洞（碎片）。这些已删除记录连接起来，就会成为页面的自由空间链表。</li>
<li>未分配空间：指页面未使用的存储空间，随着页面不断使用，未分配空间将会越来越小。当新插入一条记录时，首先尝试从自由空间链表中获得合适的存储位置（空间足够），如果没有满足的，就会在未分配空间中申请。</li>
<li>slot区：slot是一些页面有效记录的指针，每个slot占两个字节，存储了记录相对页面首地址的偏移。如果页面有n条有效记录，那么slot的数量就在n/8+2~n/4+2之间。它是记录页面有序和二分查找的关键。</li>
<li>页尾（Page Tailer）：页面最后部分，占8个字节，主要存储页面的校验信息。<br>页面中的页头，最大/最小虚记录以及页尾都是页面中有固定的存储位置。<br>InnoDB和大多数行式数据库一样，记录以行的格式存储，它提供了两种格式：Compact（5.0版本之后）和Redundant（5.0版本之前），我们只讲Compact格式，Redundant可以参考其他资料。</li>
</ol>
<p><strong>Compact</strong></p>
<p>Compact格式是在MySQL5.0时才被引入，它是新的行格式，其设计目标是高效存放数据，示意图如下：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image10.jpg" alt=""></p>
<ol>
<li>变长字段长度列表。按列的逆序放置，当列长度小于255字节，用1字节表示，若大于255字节，用2个字节表示，至多为2字节（这也很好解释了InnoDB中varchar的最大长度为什么是65535，因为2个字节为16位，2的16次方-1）。注意，对于固定长度字段（如char），是不需要记录其长度的。</li>
<li>NULL标志位。指示该行中的列是否为NULL，1表示NULL。</li>
<li>记录头信息。固定占用5个字节（40位）。</li>
<li>最后就是实际存储的该行每列的数据了，注意：NULL不在该部分中占用存储。</li>
<li>此外还有两个隐藏部分，分别存放事务ID和回滚指针，大小分别为6字节和7字节，如果表没有定义主键，每行还会自动增加6字节的ROWID。</li>
</ol>
<p>变长字符字段最大支持65532个字符，当行数据大小超过16Kb时，会在数据页中存放部分字节的前缀数据，之后都是偏移量，指向益出页（Uncompressed Blob Page）。一个页中至少存放两行记录。当行数据的大小很小（即便是varchar、blob、text字段），也可能存放在数据页中。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>InnoDB使用B+Tree的方式存储索引， Innodb的一个表可能包含多个索引，每个索引都使用B+树来存储。而索引包括聚集索引和二级索引，聚集索引使用表的主键作为索引键，包含表的所有字段。二级索引只包含索引键和聚集索引键（主键）的内容，不包括其他字段。每一个索引都是一棵B+树，每棵B+树由很多页面组成，而每个页面大小一般为16K。从B+树的组织结构来看，B树的页面可分为：</p>
<ul>
<li>叶子节点：B树层次为0的页面，存储记录的所有内容</li>
<li>非叶子节点：B树层次大于0的页面，只存储索引键和页面指针。</li>
</ul>
<p>一棵典型的B+树结构：</p>
<p><img src="/img/doc/mysql/Manual-MySQL-20170702/image11.jpg" alt=""></p>
<p>从上图可知，相同层次的页面是用一个双向链表连接起来的。一般情况下，从B+树的最左边叶子节点开始，一直向右扫描，就可以得到B+树的从小到大的所有数据。因此，对于叶子节点，有如下特征：</p>
<ul>
<li>页内数据是按索引键排序的。</li>
<li>页面的任一记录的索引键值不小于其左兄弟页面的任何记录。</li>
<li>不可能在非叶子结点命中，只有达到叶子结点才命中；</li>
<li>非叶子结点相当于是叶子结点的索引，叶子结点是存储（关键字）数据的数据层；</li>
</ul>
<p>B+树的特性决定了索引的限制：</p>
<ul>
<li>必须从索引的最左列开始寻找</li>
<li>不能跳过索引中的列</li>
<li>范围查找列之后的索引列无法使用</li>
</ul>
<h4 id="聚簇索引VS辅助索引"><a href="#聚簇索引VS辅助索引" class="headerlink" title="聚簇索引VS辅助索引"></a>聚簇索引VS辅助索引</h4><p><strong>聚簇索引：</strong><br>索引指针直接指向数据页的索引，聚簇索引对数据物理页按索引键值进行物理组织排序；</p>
<p><strong>主键索引：</strong><br>建在主键上的索引；innodb中，聚簇索引在有主键的情况下，默认指定主键为聚簇索引,因此,innodb中，主键索引一般都是聚簇索引。</p>
<p><strong>二级索引：</strong><br>除了聚簇索引的，都称为2级索引；innodb中，二级索引查找数据行，需要先找到对应的主键，然后根据主键查找对应的行值。</p>
<p>innodb中，聚簇索引是mysql自己来决定的。选择的顺序是：</p>
<ol>
<li>定义了主键，就选择主键；</li>
<li>没有主键，选择第一个非空的唯一索引；</li>
<li>两者都没有，innodb自己生成一个占6byte的自增长列。然后以它作为聚簇索引列</li>
</ol>
<h4 id="索引执行计划—Explain字段解析"><a href="#索引执行计划—Explain字段解析" class="headerlink" title="索引执行计划—Explain字段解析"></a>索引执行计划—Explain字段解析</h4><p>参考附录三</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录一：MySQL基本数据类型"><a href="#附录一：MySQL基本数据类型" class="headerlink" title="附录一：MySQL基本数据类型"></a>附录一：MySQL基本数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>字节</th>
<th>推荐使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SMALLINT</td>
<td>整数，从-32000到 +32000范围</td>
<td>2</td>
<td>存储相对比较小的整数。比如: 年纪，数量</td>
</tr>
<tr>
<td>INT</td>
<td>整数，从-2000000000 到 +2000000000 范围</td>
<td>4</td>
<td>存储中等整数例如: 距离</td>
</tr>
<tr>
<td>BIGINT</td>
<td>不能用SMALLINT 或 INT描述的超大整数。</td>
<td>8</td>
<td>存储超大的整数例如: 科学/数学数据</td>
</tr>
<tr>
<td>FLOAT</td>
<td>单精度浮点型数据</td>
<td>4</td>
<td>存储小数数据例如:测量，温度</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点型数据</td>
<td>8</td>
<td>需要双精度存储的小数数据例如:科学数据</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>用户自定义精度的浮点型数据</td>
<td>变量;取决于精度与长度</td>
<td>以特别高的精度存储小数数据。例如:货币数额，科学数据</td>
</tr>
<tr>
<td>CHAR</td>
<td>固定长度的字符串</td>
<td>特定字符串长度(高达255字符)</td>
<td>存储通常包含预定义字符串的变量例如: 定期航线，国家或邮编</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>具有最大限制的可变长度的字符串</td>
<td>1 + 实际字符串长度</td>
<td>存储不同长度的字符串值(高达一个特定的最大限度).例如:名字，密码，短文标签</td>
</tr>
<tr>
<td>TEXT</td>
<td>没有最大长度限制的可变长度的字符串</td>
<td>2 +实际字符串长度</td>
<td>存储大型文本数据例如: 新闻故事，产品描述</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制字符串</td>
<td>变量；2 + 实际字符串长度</td>
<td>存储二进制数据例如:图片，附件，二进制文档</td>
</tr>
<tr>
<td>DATE</td>
<td>以 yyyy-mm-dd格式的日期</td>
<td>3</td>
<td>存储日期例如:生日，产品满期</td>
</tr>
<tr>
<td>TIME</td>
<td>以 hh:mm:ss格式的时间</td>
<td>3</td>
<td>存储时间或时间间隔例如:报警声，两时间之间的间隔，任务开始/结束时间</td>
</tr>
<tr>
<td>DATETIME</td>
<td>以yyyy-mm-ddhh:mm:ss格式结合日期和时间</td>
<td>8</td>
<td>存储包含日期和时间的数据例如:提醒的人，事件</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>以yyyy-mm-ddhh:mm:ss格式结合日期和时间</td>
<td>4</td>
<td>记录即时时间例如：事件提醒器，&quot;最后进入&quot;的时间标记</td>
</tr>
<tr>
<td>YEAR</td>
<td>以 yyyy格式的年份</td>
<td>1</td>
<td>存储年份例如:毕业年，出生年</td>
</tr>
<tr>
<td>ENUM</td>
<td>一组数据，用户可从中选择其中一个</td>
<td>1或 2个字节</td>
<td>存储字符属性，只能从中选择之一例如:布尔量选择，如性别</td>
</tr>
<tr>
<td>SET</td>
<td>一组数据，用户可从中选择其中0，1或更多。</td>
<td>从1到8字节;取决于设置的大小</td>
<td>存储字符属性，可从中选择多个字符的联合。例如:多选项选择，比如业余爱好和兴趣。</td>
</tr>
</tbody>
</table>
<h3 id="附录二：MySQL库表设计规范"><a href="#附录二：MySQL库表设计规范" class="headerlink" title="附录二：MySQL库表设计规范"></a>附录二：MySQL库表设计规范</h3><h4 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h4><ol>
<li>表必须定义主键，默认为ID，整型自增，如果不采用默认设计必须咨询DBA进行设计评估</li>
<li>ID字段作为自增主键，禁止在非事务内作为上下文作为条件进行数据传递，禁止非自增非数字类型主键设计出现</li>
<li>禁止使用外键,触发器,存储过程</li>
<li>多表中的相同列，必须保证列定义一致</li>
<li>表默认使用InnoDB，国内表字符集默认使用gbk，国际默认使用utf8的表</li>
<li>表必须包含gmt_create和gmt_modified字段，即表必须包含记录创建时间和修改时间的字段</li>
<li>单表一到两年内数据量超过500w或数据容量超过10G考虑分表，且需要提前考虑历史数据迁移或应用自行删除历史数据</li>
<li>单条记录大小禁止超过8k（列长度(中文)<em>2（gbk）/3(utf8)+列长度(英文)</em>1）</li>
<li>日志类数据不建议存储在MySQL上，优先考虑Hbase或OB，如需要存储请找DBA评估使用压缩表存储</li>
<li>主键不允许修改，如特殊需求，需要提前一个月和DBA沟通方案</li>
<li><p>绝对禁止使用MySQL保留关键字作为表名、列名、索引名等</p>
<p>   关键字列表：<br><br>   MySQL5.6：<a href="http://dev.mysql.com/doc/refman/5.6/en/keywords.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.6/en/keywords.html</a><br><br>   MySQL5.5：<a href="http://dev.mysql.com/doc/refman/5.5/en/keywords.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.5/en/keywords.html</a></p>
</li>
<li><p>可变长度设计(例如varchar)一定要按照需要设计，同时控制单行长度，如果过大会降低数据库Buffer命中率，导致更新、查询性能下降</p>
</li>
</ol>
<h4 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h4><ol>
<li>表被索引列必须定义为not null，并设置default值</li>
<li>禁止使用float、double类型，建议使用decimal替代</li>
<li>禁止使用blob、text类型保留大文本、文件、图片，建议使用其他方式存储（TFS/SFS），数据库(MySQL/Oracle)只保存指针信息</li>
<li>禁止使用varchar类型作为主键语句设计</li>
</ol>
<h3 id="附录三：Mysql-Explain-详解"><a href="#附录三：Mysql-Explain-详解" class="headerlink" title="附录三：Mysql Explain 详解"></a>附录三：Mysql Explain 详解</h3><p>语法: <code>explain &lt; table_name</code><br><br>例如: <code>explain select * from t3 where id=3952602;</code></p>
<h4 id="explain输出解释"><a href="#explain输出解释" class="headerlink" title="explain输出解释"></a>explain输出解释</h4><p>+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br><br>| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows | Extra |<br><br>+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br></p>
<p>其中type、key、key_len、ref、rows、Extra这几个关键字的信息比较重要。     </p>
<p><strong>id</strong></p>
<p>  我的理解是SQL执行的顺利的标识,SQL从大到小的执行。</p>
<p><strong>select_type</strong></p>
<p>就是select类型,可以有以下几种:</p>
<p>(1) SIMPLE</p>
<p>简单SELECT(不使用UNION或子查询等) 例如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3 where id=3952602;</div></pre></td></tr></table></figure></p>
<p>(2) PRIMARY</p>
<p>复合查询最外层的select.</p>
<p>(3) UNION</p>
<p>UNION中的第二个或后面的SELECT语句.例如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3 where id=3952602 union all select * from t3 ;</div></pre></td></tr></table></figure></p>
<p>+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br><br>| id | select_type  | table      | type  | possible_keys     | key     | key_len | ref   | rows | Extra |<br><br>+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br><br>|  1 | PRIMARY      | t3         | const | PRIMARY,idx_t3_id | PRIMARY | 4       | const |    1 |       |<br><br>|  2 | UNION        | t3         | ALL   | NULL              | NULL    | NULL    | NULL  | 1000 |       ||NULL | UNION RESULT | <union1,2 |="" all="" null="" |<br=""><br>+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br></union1,2></p>
<p>(4) DEPENDENT UNION</p>
<p>UNION中的第二个或后面的SELECT语句，取决于外面的查询<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3 where id in (select id from t3 where id=3952602 union all select id from t3);+----+--------------------+------------+--------+-------------------+---------+---------+-------+------+--------------------------+| id | select_type        | table      | type   | possible_keys     | key     | key_len | ref   | rows | Extra                    |+----+--------------------+------------+--------+-------------------+---------+---------+-------+------+--------------------------+|  1 | PRIMARY            | t3         | ALL    | NULL              | NULL    | NULL    | NULL  | 1000 | Using where              ||  2 | DEPENDENT SUBQUERY | t3         | const  | PRIMARY,idx_t3_id | PRIMARY | 4       | const |    1 | Using index              ||  3 | DEPENDENT UNION    | t3         | eq_ref | PRIMARY,idx_t3_id | PRIMARY | 4       | func  |    1 | Using where; Using index ||NULL | UNION RESULT       | &lt;union2,3 | ALL    | NULL              | NULL    | NULL    | NULL  | NULL |                          |+----+--------------------+------------+--------+-------------------+---------+---------+-------+------+--------------------------+</div></pre></td></tr></table></figure></p>
<p>(5) UNION RESULT</p>
<p>UNION的结果。</p>
<p>(6) SUBQUERY</p>
<p>子查询中的第一个SELECT.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3 where id = (select id from t3 where id=3952602);</div></pre></td></tr></table></figure></p>
<p>+—-+————-+——-+——-+——————-+———+———+——-+——+————-+<br><br>| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows | Extra       |<br><br>+—-+————-+——-+——-+——————-+———+———+——-+——+————-+<br><br>|  1 | PRIMARY     | t3    | const | PRIMARY,idx_t3_id | PRIMARY | 4       | const |    1 |             |<br><br>|  2 | SUBQUERY    | t3    | const | PRIMARY,idx_t3_id | PRIMARY | 4       |       |    1 | Using index |<br><br>+—-+————-+——-+——-+——————-+———+———+——-+——+————-+<br></p>
<p>(7) DEPENDENT SUBQUERY</p>
<p>子查询中的第一个SELECT，取决于外面的查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select id from t3 where id in (select id from t3 where id=3952602 )  ;</div></pre></td></tr></table></figure>
<p>+—-+——————–+——-+——-+——————-+———+———+——-+——+————————–+<br><br>| id | select_type        | table | type  | possible_keys     | key     | key_len | ref   | rows | Extra                    |<br><br>+—-+——————–+——-+——-+——————-+———+———+——-+——+————————–+<br><br>|  1 | PRIMARY            | t3    | index | NULL              | PRIMARY | 4       | NULL  | 1000 | Using where; Using index |<br><br>|  2 | DEPENDENT SUBQUERY | t3    | const | PRIMARY,idx_t3_id | PRIMARY | 4       | const |    1 | Using index              |<br><br>+—-+——————–+——-+——-+——————-+———+———+——-+——+————————–+<br><br>(8) DERIVED</p>
<p>派生表的SELECT(FROM子句的子查询)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from (select * from t3 where id=3952602) a ;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br><br>| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |<br><br>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br><br>|  1 | PRIMARY     | <derived2 1="" |="" system="" null="" |<br=""><br>|  2 | DERIVED     | t3         | const  | PRIMARY,idx_t3_id | PRIMARY | 4       |      |    1 |       |<br><br>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br></derived2></p>
<p><strong>table</strong></p>
<p>显示这一行的数据是关于哪张表的。有时不是真实的表名字,看到的是derivedx(x是个数字,是第几步执行的结果)。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from (select * from ( select * from t3 where id=3952602) a) b;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br><br>| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |<br><br>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br><br>|  1 | PRIMARY     | <derived2 1="" |="" system="" null="" |<br=""><br>|  2 | DERIVED     | <derived3 1="" |="" system="" null="" |<br=""><br>|  3 | DERIVED     | t3         | const  | PRIMARY,idx_t3_id | PRIMARY | 4       |      |    1 |       |<br><br>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br></derived3></derived2></p>
<p><strong>type</strong></p>
<p>这列很重要,显示了连接使用了哪种类别,有无使用索引.从最好到最差的连接类型为const、eq_ref、ref、range、index和ALL </p>
<p>(1) system</p>
<p>这是const联接类型的一个特例。表仅有一行满足条件。如下(t3表上的id是 primary key)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from (select * from t3 where id=3952602) a ;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br><br>| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |<br><br>+—-+————-+————+——–+——————-+———+———+——+——+——-+<br><br>|  1 | PRIMARY     | <derived2 1="" |="" system="" null="" |<br=""><br>|  2 | DERIVED     | t3         | const  | PRIMARY,idx_t3_id | PRIMARY | 4       |      |    1 |       |<br><br>+—-+————-+————+——–+——————-+———+———+——+——+——-+</derived2></p>
<p>(2)const</p>
<p>表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器认为是常数。const表很快，因为它们只读取一次！const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。在下面的查询中，tbl_name可以用于const表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> tbl_name <span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">and</span> primary_key_part2=<span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>例如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3 where id=3952602;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br><br>| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows | Extra |<br><br>+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br><br>|  1 | SIMPLE      | t3    | const | PRIMARY,idx_t3_id | PRIMARY | 4       | const |    1 |       |<br><br>+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br></p>
<p>(3) eq_ref</p>
<p>除了const类型。一个索引被联接使用并且索引是UNIQUE或PRIMARY KEY。且使用=操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。在下面的例子中，MySQL可以使用eq_ref联接来处理ref_tables：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>例如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;create unique index idx_t3_id on t3(id) ;</div></pre></td></tr></table></figure></p>
<p>Query OK, 1000 rows affected (0.03 sec)<br><br>Records: 1000  Duplicates: 0  Warnings: 0<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3,t4 where t3.id=t4.accountid;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+——-+——–+——————-+———–+———+———————-+——+——-+<br><br>| id | select_type | table | type   | possible_keys     | key       | key_len | ref                  | rows | Extra |<br><br>+—-+————-+——-+——–+——————-+———–+———+———————-+——+——-+<br><br>|  1 | SIMPLE      | t4    | ALL    | NULL              | NULL      | NULL    | NULL                 | 1000 |       |<br><br>|  1 | SIMPLE      | t3    | eq_ref | PRIMARY,idx_t3_id | idx_t3_id | 4       | dbatest.t4.accountid |    1 |       |<br><br>+—-+————-+——-+——–+——————-+———–+———+———————-+——+——-+<br></p>
<p> (4) ref</p>
<p>如果联接只使用主键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或&lt;=操作符的带索引的列。在下面的例子中，MySQL可以使用ref联接来处理ref_tables：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>例如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;drop index idx_t3_id on t3;</div></pre></td></tr></table></figure></p>
<p>Query OK, 1000 rows affected (0.03 sec)<br><br>Records: 1000  Duplicates: 0  Warnings: 0<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;create index idx_t3_id on t3(id) ;</div></pre></td></tr></table></figure></p>
<p>Query OK, 1000 rows affected (0.04 sec)<br><br>Records: 1000  Duplicates: 0  Warnings: 0<br></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3,t4 where t3.id=t4.accountid;</div></pre></td></tr></table></figure>
<p>+—-+————-+——-+——+——————-+———–+———+———————-+——+——-+<br><br>| id | select_type | table | type | possible_keys     | key       | key_len | ref                  | rows | Extra |<br><br>+—-+————-+——-+——+——————-+———–+———+———————-+——+——-+<br><br>|  1 | SIMPLE      | t4    | ALL  | NULL              | NULL      | NULL    | NULL                 | 1000 |       |<br><br>|  1 | SIMPLE      | t3    | ref  | PRIMARY,idx_t3_id | idx_t3_id | 4       | dbatest.t4.accountid |    1 |       |<br><br>+—-+————-+——-+——+——————-+———–+———+———————-+——+——-+<br></p>
<p>2 rows in set (0.00 sec)</p>
<p>(5) ref_or_null</p>
<p>该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行，在解决子查询中经常使用该联接类型的优化。<br>在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p>
<p>(6) index_merge</p>
<p>该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。例如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t4 where id=3952602 or accountid=31754306 ;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+——-+————-+—————————-+—————————-+———+——+——+——————————————————+<br><br>| id | select_type | table | type        | possible_keys              | key                        | key_len | ref  | rows | Extra                                                |<br><br>+—-+————-+——-+————-+—————————-+—————————-+———+——+——+——————————————————+<br><br>|  1 | SIMPLE      | t4    | index_merge | idx_t4_id,idx_t4_accountid | idx_t4_id,idx_t4_accountid | 4,4     | NULL |    2 | Using union(idx_t4_id,idx_t4_accountid); Using where |<br><br>+—-+————-+——-+————-+—————————-+—————————-+———+——+——+——————————————————+<br></p>
<p>1 row in set (0.00 sec)</p>
<p>(7) unique_subquery</p>
<p>该类型替换了下面形式的IN子查询的ref：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</div></pre></td></tr></table></figure></p>
<p>unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。</p>
<p>(8) index_subquery</p>
<p>该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</div></pre></td></tr></table></figure></p>
<p>(9) range</p>
<p>只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。当使用=、&lt;>、>、>=、&lt;、&lt;=、IS NULL、&lt;=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain select * from t3 where id=3952602 or id=3952603;</div></pre></td></tr></table></figure></p>
<p>+—-+————-+——-+——-+——————-+———–+———+——+——+————-+<br><br>| id | select_type | table | type  | possible_keys     | key       | key_len | ref  | rows | Extra       |<br><br>+—-+————-+——-+——-+——————-+———–+———+——+——+————-+<br><br>|  1 | SIMPLE      | t3    | range | PRIMARY,idx_t3_id | idx_t3_id | 4       | NULL |    2 | Using where |<br><br>+—-+————-+——-+——-+——————-+———–+———+——+——+————-+<br></p>
<p>1 row in set (0.02 sec)</p>
<p>(10) index</p>
<p>该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。</p>
<p>(11) ALL</p>
<p>对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。</p>
<p>possible_keys</p>
<p>possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询。</p>
<p>Key</p>
<p>key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<p>key_len</p>
<p>key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。ken_len就是真实实用索引的长度。当遇到范围查找时，该索引列之后的列不会使用，索引长度不会计算进去。</p>
<p>ken_len计算注意点：</p>
<ul>
<li>如果列可空，则该索引列长度+1，用于标记是否为空</li>
<li>utf-8使用3个字节存储一个字符，所以索引长度时字符数*3</li>
</ul>
<p>ref</p>
<p>ref列显示使用哪个列或常数与key一起从表中选择行。</p>
<p>Rows</p>
<p>rows列显示MySQL认为它执行查询时必须检查的行数。</p>
<p>Extra</p>
<p>该列包含MySQL解决查询的详细信息：</p>
<p>(1) Distinct</p>
<p>一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p>
<p>(2) Not exists</p>
<p>MYSQL优化了LEFT JOIN，一旦它找到了匹配<code>LEFT JOIN</code>标准的行，就不再搜索了</p>
<p>(3) Range checked for each</p>
<p>没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。</p>
<p>(4) Using filesort</p>
<p>看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。</p>
<p>(5) Using index</p>
<p>列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候</p>
<p>(6) Using temporary</p>
<p>看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行<code>ORDER BY</code>上，而不是<code>GROUP BY</code>上。</p>
<p>(7) Using where</p>
<p>这说明服务器在存储引擎收到行后将进行过滤。有些where中的条件会有属于索引的列，当它读取使用索引的时候，就会被过滤，所以会出现有些where语句并没有在extra列中出现using where这么一个说明。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>【1】李海翔.数据库查询优化器的艺术：原理解析与SQL性能优化[M].北京:北京华章图文信息有限公司:2014</p>
<p>【2】[美] 加西亚·莫利纳 等著，杨冬青 等译.数据库系统实现（第2版） [Database System Implementation,Second Edition][M].机械工业出版社:2010</p>
<p>【3】[美]施瓦茨 等著，宁海元等译    高性能MySQL（第3版）.电子工业出版社</p>
<p>【4】姜承尧.MySQL技术内幕:InnoDB存储引擎 第2版.[M].机械工业出版社</p>
<p>【5】<a href="http://tech.meituan.com/innodb-lock.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://tech.meituan.com/innodb-lock.html?utm_source=tuicool&amp;utm_medium=referral</a></p>
<p>【6】<a href="http://blog.csdn.net/jiangguilong2000/article/details/12200903" target="_blank" rel="external">http://blog.csdn.net/jiangguilong2000/article/details/12200903</a></p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 解析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射(Reflection)]]></title>
      <url>/2017/06/26/java/basic/Manual-Java_Reflection-20170626/</url>
      <content type="html"><![CDATA[<p>Java中很多框架和应用都会使用反射，本文简单的介绍了Java的反射。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Reflection和Introspection这两个机制都是作用在Java运行时。<br>每一个类在JVM运行时，都是一个Class实例，该对象描述了响应类的全部属性，包括Annotation、Field、Method等等。<br>Java的反射和内省都非常的使用，在比较流行的框架Spring和MyBatis中就使用了反射和内省。</p>
<p>先看一个简单的Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Objects;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</div><div class="line">        Class&lt;HashMap&gt; mapClazz = (Class&lt;HashMap&gt;) Class.forName(<span class="string">"java.util.HashMap"</span>);</div><div class="line">        System.out.println(mapClazz.getName());</div><div class="line">        System.out.println(<span class="string">"------------------------------------------"</span>);</div><div class="line">        Method[] methods = mapClazz.getMethods();</div><div class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">            System.out.print(<span class="string">" "</span> + method.getName() + <span class="string">"("</span>);</div><div class="line">            Parameter[] parameters = method.getParameters();</div><div class="line">            <span class="keyword">for</span> (Parameter parameter : parameters) &#123;</div><div class="line">                System.out.print(parameter.getType().getName() + <span class="string">","</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">");"</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"------------------------------------------"</span>);</div><div class="line">        Field[] fields = mapClazz.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">            System.out.println(<span class="string">" "</span> + Modifier.toString(field.getModifiers()) + <span class="string">" "</span> + field.getName());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Method putMethod = mapClazz.getMethod(<span class="string">"put"</span>, Object.class,Object.class);</div><div class="line">        Method getMethod = mapClazz.getMethod(<span class="string">"get"</span>,Object.class);</div><div class="line">        putMethod.invoke(map,<span class="string">"hello"</span>,<span class="string">"world"</span>);</div><div class="line">        String world = (String) getMethod.invoke(map,<span class="string">"hello"</span>);</div><div class="line">        System.out.println(<span class="string">"------------------------------------------"</span>);</div><div class="line">        System.out.println(world);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个示例中首先通过Class的描述符获取ClassLoader中对应的Class实例对象。<br>第二步，遍历该类可访问方法（包含父类继承的）。<br>第三步，遍历该类声明的属性（不包括父类声明的属性）。<br>第四步，获取Map接口的<code>put</code>方法，获取Map接口的<code>get</code>方法。通过反射得到的put方法将[“hello”:”world”]放入到map对象中，在通过反射得到的方法get，获得map中对应的value。</p>
<h4 id="Java反射的机制的主要作用："><a href="#Java反射的机制的主要作用：" class="headerlink" title="Java反射的机制的主要作用："></a>Java反射的机制的主要作用：</h4><ol>
<li>Jvm运行时校验类的信息。</li>
<li>Jvm运行时修改类或者对象的信息。</li>
<li>Jvm运行时动态创建对象实例。</li>
<li>Jvm运行时动态调用对象方法。</li>
<li>修改构造函数、方法、属性的访问权限。</li>
</ol>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ol>
<li>性能消耗<ul>
<li>由于反射是动态解析类的结构，所有不能执行包含了虚拟机优化的动作。因此，反射操作会比未使用反射的部分性能要差，应当避免在频繁调用的、性能敏感的代码块中使用反射。</li>
</ul>
</li>
<li>安全限制<ul>
<li>反射需要运行时的权限，当一个安全管理器内运行时，肯能是不存在该权限的。当代码必须在受限的安全上下文中调用时，这是一个重要的考虑因素，例如Applet。</li>
</ul>
</li>
<li>私有信息曝光<ul>
<li>由于反射允许非反射代码执行代码操作，这可能导致非法操作，例如访问私有（private）属性和变量，使用反射可能导致意外的副作用，可能是使代码功能失调和破坏可移植性。<br>反射会打破抽象设计，因此升级平台后可能导致不同的执行动作。</li>
</ul>
</li>
</ol>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在Java中，每个对象不是一个引用类型，就是一个原始类型。所有的引用类型都继承自<code>java.lang.Object</code>。类、枚举、数组和接口都是引用类型。<br>原始类型的固定集合是<code>boolean</code>、<code>char</code>、<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>。<br>对于每种类型，JVM都会实例化一个不可变的<code>java.lang.Class</code>实例，该实例提供了一系列的方法，检查该对象运行时的属性（包括成员和类型信息）。<br><code>java.lang.Class</code>还提供了创建新类和新对象的能力。最重要的是，它是所有反射接口的入口。</p>
<h4 id="Class的获取方式"><a href="#Class的获取方式" class="headerlink" title="Class的获取方式"></a>Class的获取方式</h4><p>所有反射操作的入口，都是<code>java.lang.Class</code>。有多种获取<code>java.lang.Class</code>对象的方法，使用何种，取决于代码是否有权访问该类的对象、或者该类的名称、或者一个类型、或者一个已有的<code>java.lang.Class</code>对象。</p>
<p>可以获取<code>java.lang.Class</code>的方法和描述如下：</p>
<ol>
<li>Object.getClass()</li>
</ol>
<p>如果有一个该类的实例，获取<code>Class</code>最简单的方法就是通过调用对象的<code>getClass()</code>方法获取。这只适用于引用类型的对象。<br>示例：</p>
<blockquote>
<p>Class stringClazz = “foo”.getClass()</p>
</blockquote>
<ol>
<li><code>.class</code>语法</li>
</ol>
<p>如果不能访问对象实例，可以访问对象的类型，那么可以通过”Class.class”语法获取Class实例。这个语法可用于原始类型和引用数据类型。<br>示例：</p>
<blockquote>
<p>Class intClazz = int.class;</p>
<p>Class mapClazz = java.util.Map.class;</p>
</blockquote>
<ol>
<li><code>java.lang.Class.forName</code>方法</li>
</ol>
<p>如果类的全限定名称是可用的，则可以通过静态方法<code>Class.forName</code>获取Class对象。该方法不适用于原始类型。<br>数组的全限定名称的语法可以通过”Class.getName()”方法获取。该语法适用于引用对象的数组和原始类型的数组。<br>示例：</p>
<blockquote>
<p>Class c = Class.forName(“com.duke.MyLocaleServiceProvider”);</p>
<p>Class cDoubleArray = Class.forName(“[D”);</p>
<p>Class cStringArray = Class.forName(“[[Ljava.lang.String;”);</p>
</blockquote>
<ol>
<li>原始类型包装类的TYPE属性</li>
</ol>
<p><code>.class</code>语法用于获取一个原始类型的Class对象是更为方便的方式；但还有其他获取该对象的方式。<br>每一个原始类型和void类型都有一个在<code>java.lang</code>包中的包装类，用于原始类型和引用类型之间的装箱和拆箱操作。<br>每一个对应的包装类，都有一个命名为<code>TYPE</code>的属性，这个属性的值就是被包装的原始类型的Class实例。</p>
<ol>
<li>Class.getSuperclass()</li>
</ol>
<p>返回该类的超类。</p>
<ol>
<li>Class.getClasses()</li>
</ol>
<p>返回该类声明的或者从超类声明继承的内部公共类、接口、枚举。</p>
<ol>
<li>Class.getDeclaredClasses()</li>
</ol>
<p>返回该类声明的内部类、接口、枚举。</p>
<ol>
<li>Class、Field、Method、Constructor.getDeclaringClass()</li>
</ol>
<p>返回声明该Class、Field、Method、Constructor的Class，如果Class不是被其他Class所声明的、或者是匿名内部类，则该接口返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"></div><div class="line">Field f = System.class.getField(<span class="string">"out"</span>);</div><div class="line">Class c = f.getDeclaringClass();</div></pre></td></tr></table></figure>
<ol>
<li>Class.getEnclosingClass()</li>
</ol>
<p>返回声明该内部类、或者匿名类的Class对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Object o = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> Class&lt;?&gt; c = o.getClass().getEnclosingClass();</div></pre></td></tr></table></figure>
<h3 id="Class的方法"><a href="#Class的方法" class="headerlink" title="Class的方法"></a>Class的方法</h3><p>自身非私有：自身声明的成员，包括public、protected、default</p>
<p>继承的公共：父类声明的public成员</p>
<p>自身私有：自身声明的private成员</p>
<table>
<thead>
<tr>
<th>Class接口</th>
<th>自身非私有</th>
<th>继承的公共</th>
<th>自身私有</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredField()</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>getField()</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>getFields()</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Class接口</th>
<th>自身非私有</th>
<th>继承的公共</th>
<th>自身私有</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredMethod()</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>getMethod()</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>getMethods()</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Class接口</th>
<th>自身非私有</th>
<th>继承的</th>
<th>自身私有</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDeclaredConstructor()</td>
<td>Yes</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr>
<td>getConstructor()</td>
<td>Yes</td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>Yes</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr>
<td>getConstructors()</td>
<td>Yes</td>
<td>N/A</td>
<td>No</td>
</tr>
</tbody>
</table>
<h4 id="获取父类"><a href="#获取父类" class="headerlink" title="获取父类"></a>获取父类</h4><p>通过Class实例的<code>getSuperClass()</code>方法可以获取class的父类，<br>如果该Class实例表示的是Object、一个接口、一个原始类型或者void类型，该方法会返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; superClass = HashMap.class.getSuperclass();</div><div class="line">System.out.println(superClass);                        <span class="comment">// "class java.util.AbstractMap"</span></div><div class="line">System.out.println(Object.class.getSuperclass());      <span class="comment">// "null"</span></div><div class="line">System.out.println(String[][].class.getSuperclass());  <span class="comment">// "class java.lang.Object"</span></div></pre></td></tr></table></figure>
<h4 id="获取Package"><a href="#获取Package" class="headerlink" title="获取Package"></a>获取Package</h4><p><code>getPackage()</code>将返回该类的包信息。可以调用<code>Package.getName()</code>获取包名称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(HashMap.class.getPackage().getName());</div></pre></td></tr></table></figure></p>
<p>Package 对象包含有关 Java 包的实现和规范的版本信息。<br>规范的版本号使用了一个由句点 “.” 分隔的十进制正整数组成的语法，例如 “2.0” 或 “1.2.3.4.5.6.7”。这允许使用可扩展的编号来表示主版本号、次版本号、缩微版本号，等等。</p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>Java中共有四种访问限制修饰符：private、protected、缺省、public</p>
<ul>
<li>private：私有,内部访问</li>
<li>缺省：是默认的,同一个package下可以访问。</li>
<li>protected：同一个packege或者子类可以访问</li>
<li>public:共有,都可以访问</li>
</ul>
<p>每种修饰符，具体可以修饰的组件如下：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员方法</th>
<th>构造方法</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract（抽象的）</td>
<td>√</td>
<td>√</td>
<td>－</td>
<td>－</td>
<td>－</td>
</tr>
<tr>
<td>static （静态的）</td>
<td>√</td>
<td>√</td>
<td>－</td>
<td>√</td>
<td>－</td>
</tr>
<tr>
<td>public（公共的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>－</td>
</tr>
<tr>
<td>protected（受保护的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>－</td>
<td>－</td>
</tr>
<tr>
<td>private（私有的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>－</td>
</tr>
<tr>
<td>synchronized（同步的）</td>
<td>－</td>
<td>√</td>
<td>－</td>
<td>－</td>
<td>－</td>
</tr>
<tr>
<td>native（本地的）</td>
<td>－</td>
<td>√</td>
<td>－</td>
<td>－</td>
<td>－</td>
</tr>
<tr>
<td>transient（暂时的）</td>
<td>－</td>
<td>－</td>
<td>－</td>
<td>√</td>
<td>－</td>
</tr>
<tr>
<td>volatie（易失的）</td>
<td>－</td>
<td>－</td>
<td>－</td>
<td>√</td>
<td>－</td>
</tr>
<tr>
<td>final（不要改变的）</td>
<td>√</td>
<td>√</td>
<td>－</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(Modifier.toString(HashMap.class.getModifiers())); </div><div class="line"><span class="comment">//"public"</span></div><div class="line">System.out.println(Modifier.toString(AbstractMap.class.getModifiers()));</div><div class="line"><span class="comment">//"public abstract"</span></div></pre></td></tr></table></figure>
<h4 id="泛型的参数"><a href="#泛型的参数" class="headerlink" title="泛型的参数"></a>泛型的参数</h4><p><code>getTypeParameters()</code>方法按照顺序返回定义该类所使用泛型参数信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; hashClass = HashMap.class.getSuperclass();</div><div class="line">TypeVariable&lt;?&gt;[] typeParameters = hashClass.getTypeParameters();</div><div class="line"><span class="keyword">for</span> (TypeVariable&lt;?&gt; typeVariable : typeParameters) &#123;</div><div class="line">    System.out.print(typeVariable+<span class="string">","</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出 K,V,</span></div></pre></td></tr></table></figure></p>
<h4 id="获取所有实现的接口"><a href="#获取所有实现的接口" class="headerlink" title="获取所有实现的接口"></a>获取所有实现的接口</h4><p><code>getGenericInterfaces()</code>：该方法返回一个Type数组，携带了泛型信息。表示该class所有实现的接口集合。<br><code>getInterfaces()</code>：该方法返回一个Class数组。表示该class所有实现的接口集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; listClass = ArrayList.class;</div><div class="line">Type[] typeInterfaces = listClass.getGenericInterfaces();</div><div class="line">System.out.println(Arrays.toString(typeInterfaces));</div><div class="line"><span class="comment">// [java.util.List&lt;E&gt;, interface java.util.RandomAccess, interface java.lang.Cloneable, interface java.io.Serializable]</span></div><div class="line">Class[] interfaces = listClass.getInterfaces();</div><div class="line">System.out.println(Arrays.toString(interfaces));</div><div class="line"><span class="comment">//[interface java.util.List, interface java.util.RandomAccess, interface java.lang.Cloneable, interface java.io.Serializable]</span></div></pre></td></tr></table></figure>
<h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><p>首先声明一个Demo类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> String name = <span class="string">"demo"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 无参公共构造函数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Person <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"age="</span> + age + <span class="string">", name='"</span> + name + <span class="string">'\''</span> + <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="获取-设置公共属性"><a href="#获取-设置公共属性" class="headerlink" title="获取/设置公共属性"></a>获取/设置公共属性</h4><p><code>get()</code>方法返回的是一个对象，所以原始类型的属性，会返回相应的包装类。<br> 如果属性是<code>static</code>的，那么方法的对象入参需要是<code>null</code>。</p>
<p>有一系列的<code>set*()</code>方法，用于设置不同的类型的属性，需要获取相应属性的类型，来确定使用正确的<code>set</code>方法。<br>如果属性是<code>final</code>的，则会抛出<code>java.lang.IllegalAccessException</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Field field = Person.class.getField(<span class="string">"name"</span>);</div><div class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"demo-01"</span>);</div><div class="line">System.out.println(field.get(person)); <span class="comment">//demo-01</span></div><div class="line">field.set(person, <span class="string">"demo-02"</span>); <span class="comment">//设置成 demo-02</span></div><div class="line">System.out.println(field.get(person)); <span class="comment">//demo-01</span></div></pre></td></tr></table></figure></p>
<h4 id="获取-设置私有成员变量"><a href="#获取-设置私有成员变量" class="headerlink" title="获取/设置私有成员变量"></a>获取/设置私有成员变量</h4><p>私有的属性在类的外部是不能被访问的，但是使用反射，我们可以关闭私有属性的访问限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Field field = Person.class.getDeclaredField(<span class="string">"age"</span>);</div><div class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"demo-01"</span>);</div><div class="line">field.setAccessible(<span class="keyword">true</span>); <span class="comment">//关闭访问限制</span></div><div class="line">System.out.println(field.get(person)); <span class="comment">// 1</span></div><div class="line">field.set(person, <span class="number">2</span>); <span class="comment">//设置成 2</span></div><div class="line">System.out.println(field.get(person)); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h4 id="调用公共方法"><a href="#调用公共方法" class="headerlink" title="调用公共方法"></a>调用公共方法</h4><p>我们可以通过调用<code>Method.invoke()</code>方法来调用一个方法。<br>如果这个方法是一个<code>static</code>的方法，则相应的对象入参，需要设置为<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Method setMethod = Person.class.getMethod(<span class="string">"setName"</span>, String.class);</div><div class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"demo-01"</span>);</div><div class="line">System.out.println(setMethod.invoke(person, <span class="string">"demo-02"</span>));</div><div class="line">Method getMethod = Person.class.getMethod(<span class="string">"getName"</span>);</div><div class="line">System.out.println(getMethod.invoke(person)); <span class="comment">//demo-02</span></div></pre></td></tr></table></figure>
<h4 id="调用私有方法"><a href="#调用私有方法" class="headerlink" title="调用私有方法"></a>调用私有方法</h4><p>调用私有方法需要使用<code>setAccessible()</code>方法关闭访问限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Method setMethod = Person.class.getDeclaredMethod(<span class="string">"setAge"</span>, <span class="keyword">int</span>.class);</div><div class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"demo-01"</span>);</div><div class="line">setMethod.setAccessible(<span class="keyword">true</span>);<span class="comment">//关闭访问限制</span></div><div class="line">System.out.println(setMethod.invoke(person, <span class="number">2</span>));</div><div class="line">Method getMethod = Person.class.getDeclaredMethod(<span class="string">"getAge"</span>);</div><div class="line">getMethod.setAccessible(<span class="keyword">true</span>);<span class="comment">//关闭访问限制</span></div><div class="line">System.out.println(getMethod.invoke(person)); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们可以通过调用构造函数的<code>newInstance()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取无参构造函数</span></div><div class="line">Constructor&lt;Person&gt; constructor = Person.class.getDeclaredConstructor();</div><div class="line">constructor.setAccessible(<span class="keyword">true</span>);<span class="comment">//关闭访问限制</span></div><div class="line">Person person = constructor.newInstance();</div><div class="line">System.out.println(person);<span class="comment">// Person&#123;age=0, name='demo'&#125;</span></div><div class="line"></div><div class="line"><span class="comment">//获取入参属性顺序是int.class、String.class的构造函数</span></div><div class="line">constructor = Person.class.getConstructor(<span class="keyword">int</span>.class, String.class);</div><div class="line">person = constructor.newInstance(<span class="number">1</span>, <span class="string">"demo-2"</span>);</div><div class="line">System.out.println(person);<span class="comment">// Person&#123;age=1, name='demo-2'&#125;</span></div></pre></td></tr></table></figure>
<ol>
<li><p><a href="http://tutorials.jenkov.com/java-reflection/index.html" target="_blank" rel="external">参考文章：http://tutorials.jenkov.com/java-reflection/index.html</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="external">参考文章： http://docs.oracle.com/javase/tutorial/reflect/index.html</a></p>
</li>
</ol>
<div style="display: none;"><br>TODO:<br> 注解、泛型、数组<br></div>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Manual </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
